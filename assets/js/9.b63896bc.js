(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{331:function(t,e,a){t.exports=a.p+"assets/img/bb.b6732d42.jpg"},332:function(t,e,a){t.exports=a.p+"assets/img/aa.1ea03e7a.png"},333:function(t,e,a){t.exports=a.p+"assets/img/dd.e3e4bff8.png"},334:function(t,e,a){t.exports=a.p+"assets/img/ee.bf56102f.png"},335:function(t,e,a){t.exports=a.p+"assets/img/ff.0a20e1ae.png"},403:function(t,e,a){"use strict";a.r(e);var r=a(3),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"观察者模式（observer）"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式（observer）"}},[t._v("#")]),t._v(" 观察者模式（Observer）")]),t._v(" "),r("ul",[r("li",[t._v("观察者模式是实现"),r("br"),t._v("一对多"),r("br"),t._v("关系解耦的行为设计模式。它主要设计两个角色：观察\n目标，观察者。")]),t._v(" "),r("li",[t._v("它的特点： 观察者要直接订阅观察目标，观察目标一旦做出通知，观察者就要进行处理")]),t._v(" "),r("li",[t._v("(这也是观察者模式区别于发布/订阅模式的最大区别)发布订阅模式其解耦能力更近一步，\n观察者只要做好消息的发布，而不关心有没有被订阅者订阅。而观察者模式则要求两端同时存在。")])]),t._v(" "),r("h2",{attrs:{id:"依赖收集-https-zhuanlan-zhihu-com-p-45081605"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#依赖收集-https-zhuanlan-zhihu-com-p-45081605"}},[t._v("#")]),t._v(" 依赖收集[https://zhuanlan.zhihu.com/p/45081605]")]),t._v(" "),r("ul",[r("li",[t._v("Vue能够实现当一个数据变更时，视图就进行刷新，而且用到这个数据的其他地方也会同步更新；\n并且这个数据必须在有被依赖的情况下，视图其其他用到该数据的地方才会同步更新，所以Vue要能够知道\n一个数据是否被使用，实现这种机制的技术叫做"),r("br"),t._v("依赖收集"),r("br"),t._v(" "),r("img",{attrs:{src:a(331),alt:"avatar"}})]),t._v(" "),r("li",[t._v("每个组件实例都有相应的watcher实例--渲染组建的过程，会把属性记录为依赖，当我们操作一个数据时，依赖项\n的setter会被调用，从而通知watcher重新计算，从而致使与之相关联的组件得以更新。")]),t._v(" "),r("li",[t._v("既然模板渲染需要用到某个数据，那么一定会对这个数据进行访问，所以只要拦截getter，就有时机做出处理，在值\n变更的时候，也有setter能获得这个通知，从而告知render()函数进行重新计算")]),t._v(" "),r("li",[t._v("所以在getter里，我们进行依赖收集(所谓依赖收集，就是这个组件所需要依赖的数据)，当依赖的数据被设置时，setter\n能获取这个通知，从而告诉render()函数进行重新计算。")])]),t._v(" "),r("p",[t._v("##依赖收集和观察者模式")]),t._v(" "),r("ul",[r("li",[t._v("Vue依赖收集的场景，"),r("br"),t._v("一对多"),r("br"),t._v("的方式（一个数据变更了，多个用到这个数据的地方也能够做出处理）。\n而且，依赖的数据变更了，就一定要做出处理，所以，观察者模式天然适用于解决依赖收集的问题。显然，观察目标\n是"),r("br"),t._v("依赖的数据"),r("br"),t._v("。观察者是"),r("br"),t._v("视图、计算属性、侦听器"),r("br")])]),t._v(" "),r("h2",{attrs:{id:"从源码解析依赖收集"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从源码解析依赖收集"}},[t._v("#")]),t._v(" 从源码解析依赖收集")]),t._v(" "),r("h3",{attrs:{id:"vue源码中实现依赖收集的三个类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue源码中实现依赖收集的三个类"}},[t._v("#")]),t._v(" Vue源码中实现依赖收集的三个类:")]),t._v(" "),r("ul",[r("li",[t._v("Dep 扮演 观察目标 的角色，每个数据都会有一个Dep类实例。subs，Dep内部有个subs队列，保存着依赖本对象的 观察者，\n当本数据变更时，调用dep.notify()，通知观察者watcher")]),t._v(" "),r("li",[t._v("watcher, 扮演 观察者 的角色，进行观察者函数的包装处理。如render()函数，会被包装成一个watcher实例")]),t._v(" "),r("li",[t._v("Observer, 辅助的 可观测类，数组/对象通过它的转化，可成为可观测数据。将Observer类的实例挂载在__ob__属性上，\n提供后续观测数据使用，以及避免被重复实例化。然后，实例化Dep类实例，并且将对象/数组作为value属性保存下来\n如果value是个对象，就执行walk()过程，遍历对象把每一项数据都变为可观测数据（调用defineReactive方法处理） -\n如果value是个数组，就执行observeArray()过程，递归地对数组元素调用observe()，\n以便能够对元素还是数组的情况进行处理")]),t._v(" "),r("li",[t._v("由于JavaScript是单线程模型，所以虽然有多个观察者函数，但是一个时刻内，就只会有一个观察者函数在执行。\n那么此刻正在执行的那个观察者函数，所对应的Watcher实例，便会被赋给Dep.target这一类变量，\n从而只要访问Dep.target就能知道当前的观察者是谁。 在后续的依赖收集工作里，getter里会调用dep.depend()，\n而setter里则会调用dep.notify()")])]),t._v(" "),r("h3",{attrs:{id:"核心实现类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#核心实现类"}},[t._v("#")]),t._v(" 核心实现类")]),t._v(" "),r("ul",[r("li",[t._v("observer:它的作用是给对象的属性添加getter和setter，用于依赖收集和派发更新")]),t._v(" "),r("li",[t._v("Dep: 在数据劫持时，getter会通过dep.depend收集依赖。setter会通过dep.notify派发更新")]),t._v(" "),r("li",[t._v("watcher: 观察者对象，实例分为渲染(render watcher)，计算属性(computed watcher),\n侦听器(user watcher)")])]),t._v(" "),r("h3",{attrs:{id:"更新派发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更新派发"}},[t._v("#")]),t._v(" 更新派发")]),t._v(" "),r("ul",[r("li",[t._v("组件中对响应式的数据进行修改，触发setter的逻辑")]),t._v(" "),r("li",[t._v("调用dep.notify()")]),t._v(" "),r("li",[t._v("遍历所有的subs (watcher实例)，调用每一个watcher的update方法")])]),t._v(" "),r("h2",{attrs:{id:"依赖收集原理："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#依赖收集原理："}},[t._v("#")]),t._v(" 依赖收集原理：")]),t._v(" "),r("p",[r("img",{attrs:{src:a(332),alt:"avatar"}})]),t._v(" "),r("h2",{attrs:{id:"配置依赖观测"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#配置依赖观测"}},[t._v("#")]),t._v(" 配置依赖观测")]),t._v(" "),r("p",[r("img",{attrs:{src:a(333),alt:"avatar"}})]),t._v(" "),r("h2",{attrs:{id:"收集依赖"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#收集依赖"}},[t._v("#")]),t._v(" 收集依赖")]),t._v(" "),r("p",[r("img",{attrs:{src:a(334),alt:"avatar"}})]),t._v(" "),r("h2",{attrs:{id:"数据值变更"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据值变更"}},[t._v("#")]),t._v(" 数据值变更")]),t._v(" "),r("p",[r("img",{attrs:{src:a(335),alt:"avatar"}})])])}),[],!1,null,null,null);e.default=s.exports}}]);