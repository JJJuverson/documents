(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{411:function(t,a,e){"use strict";e.r(a);var v=e(3),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"vue的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期"}},[t._v("#")]),t._v(" vue的生命周期")]),t._v(" "),e("ul",[e("li",[t._v("在beforeCreate钩子函数调用的时候，是获取不到props或者data中的数据，因为这些数据初始化\n都在initState中")]),t._v(" "),e("li",[t._v("然后执行created钩子函数时，可以访问到之前不能访问到的数据，但是这时候的组件还没被挂载，\n所以看不到")]),t._v(" "),e("li",[t._v("接下来会执行beforeMounted钩子函数，还是创建VDOM，最后执行mounted钩子，并将VDOM渲染成\n真实DOM，并且渲染数据，组件中如果有子组件，会递归挂载子组件，只有当子组件全部挂载完毕，才会\n执行根组件的挂载钩子")]),t._v(" "),e("li",[t._v("接下来是数据跟新时会调用钩子beforeUpdata和updated，分别对应跟新前和跟新后调用")]),t._v(" "),e("li",[t._v("keep-alive独有的生命周期分别时activated和deactivated.用keep-alive包裹的组件不会被销毁，而\n缓存到内存中并执行deactivated钩子。对应的缓存渲染后会执行activated钩子")])]),t._v(" "),e("h2",{attrs:{id:"vue通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue通信"}},[t._v("#")]),t._v(" Vue通信")]),t._v(" "),e("ul",[e("li",[t._v("父组件通过props传递给子组件，子组件通过$emit发送事件传递给父组件\n这种通信方式时单向的，父组件通过props传递数据，子组件不能修改props，必须通过发送事件的方式\n告知父组件修改数据")]),t._v(" "),e("li",[t._v("兄弟之间可以通过查找父组件中的子组件来实现，也就是this.$parent.$children在$children中可以\n通过组件name查询需要的组件实例，然后进行通信")]),t._v(" "),e("li",[t._v("跨多层组件可以使用API provide/inject。")]),t._v(" "),e("li",[t._v("任意组件可以通过Vuex或者EventBus")])]),t._v(" "),e("h2",{attrs:{id:"原型对象、原型链及功能（）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型对象、原型链及功能（）"}},[t._v("#")]),t._v(" 原型对象、原型链及功能（）")]),t._v(" "),e("ul",[e("li",[t._v("构造函数的prototype将成为new出来实例的原型，原型的功能是将所有类的函数方法写在原型prototype上，节约内存")]),t._v(" "),e("li",[t._v("在js中，对象都有__proto__属性，一般这个是被称为隐式的原型，该隐式原型指向构造该对象的构造函数的原型。")]),t._v(" "),e("li",[t._v("函数比较特殊，它除了和其他对象一样有__proto__属性，还有自己特有的属性---prototype它是一个指针，\n指向一个对象，这个对象包含了通过调用该构造函数所创建的对象共享的属性和方法")]),t._v(" "),e("li",[t._v("当试图访问一个对象属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象原型的原型，依次向下搜索，直到找到\n一个名字匹配的属性或者达到原型链的末尾。")])]),t._v(" "),e("h2",{attrs:{id:"new调用构造器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new调用构造器"}},[t._v("#")]),t._v(" new调用构造器")]),t._v(" "),e("ul",[e("li",[t._v("创建一个新的对象")]),t._v(" "),e("li",[t._v("将这个对象链接到原型对象上，将构造函数的作用域赋给这个对象（this指向新对象）")]),t._v(" "),e("li",[t._v("执行构造函数中的代码(为这个新对象添加属性)")]),t._v(" "),e("li",[t._v("如果这个函数有返回值，则返回，否则默认返回新对象")])]),t._v(" "),e("h2",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("ul",[e("li",[t._v("当一个内部函数被其外部函数之外的量量引用时，就形成闭包。")]),t._v(" "),e("li",[t._v("作用：实现模块化，实现变量的私有封装")]),t._v(" "),e("li",[t._v("可以实现迭代器")])]),t._v(" "),e("h2",{attrs:{id:"深浅拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深浅拷贝"}},[t._v("#")]),t._v(" 深浅拷贝")]),t._v(" "),e("ul",[e("li",[t._v("浅拷贝，创建一个新对象，这个对象有着原始对象属性值的精确拷贝。如果属性是基本属性，拷贝的是基本属性的值，\n如果属性是引用类型，拷贝的就是内存地址，如果其中一个对象改变了这个地址，就会影响到另一个对象")]),t._v(" "),e("li",[t._v("object.assign 、 concat 、slice")]),t._v(" "),e("li",[t._v("深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象")])]),t._v(" "),e("h2",{attrs:{id:"call-bind-apply"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call-bind-apply"}},[t._v("#")]),t._v(" call,bind,apply")]),t._v(" "),e("ul",[e("li",[t._v("定义上下文，指定上下文执行的函数")]),t._v(" "),e("li",[t._v("bind终身定死上下文，但不执行函数，返回新的函数")]),t._v(" "),e("li",[t._v("Fun.call(对象,参数,参数...);")]),t._v(" "),e("li",[t._v("Fun.apply(对象,[参数,参数...])")])]),t._v(" "),e("h2",{attrs:{id:"typeof-instanceof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typeof-instanceof"}},[t._v("#")]),t._v(" typeof instanceof")]),t._v(" "),e("ul",[e("li",[t._v("typeof对数值类型number,string,boolean,null,undefined,function是精准的")]),t._v(" "),e("li",[t._v("对于对象{},数组[],null 都会返回object")]),t._v(" "),e("li",[t._v("instanceof判断一个实例是否属于某种类型，只能用于对象，不能用于原始类型的值")])]),t._v(" "),e("p",[t._v("##页面加载过程")]),t._v(" "),e("h2",{attrs:{id:"promise手写"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise手写"}},[t._v("#")]),t._v(" promise手写")]),t._v(" "),e("h2",{attrs:{id:"async-await"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[t._v("#")]),t._v(" async/await")]),t._v(" "),e("h2",{attrs:{id:"generator优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#generator优势"}},[t._v("#")]),t._v(" generator优势")]),t._v(" "),e("h2",{attrs:{id:"js作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js作用域"}},[t._v("#")]),t._v(" js作用域")]),t._v(" "),e("h2",{attrs:{id:"性能，体验优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#性能，体验优化"}},[t._v("#")]),t._v(" 性能，体验优化")]),t._v(" "),e("ul",[e("li",[t._v("减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的API和构建优化")]),t._v(" "),e("li")]),t._v(" "),e("h2",{attrs:{id:"节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节流"}},[t._v("#")]),t._v(" 节流")]),t._v(" "),e("ul",[e("li",[t._v("javascript函数节流就是针对调用频率高的函数，通过设置定时器，使其在执行后间隔一段时间，\n才进行下一次的执行，避免重复频繁的调用导致的浏览器性能以及ajax重复调用问题。")]),t._v(" "),e("li",[t._v("函数节流的经典应用场景：onresize，scroll，mousemove ,mousehover等事件回调函数的无间断执行。\n其主要实现思路就是通过setTimeout定时器，通过设置缓冲时间，在第一次调用时，创建定时器，并在定时时间结束调用。\n第二次调用时，会清除前一个定时器并设置新的定时器。如果这时前一个定时器暂未执行，则将其替换为新的定时器")])]),t._v(" "),e("h2",{attrs:{id:"防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖"}},[t._v("#")]),t._v(" 防抖")]),t._v(" "),e("ul",[e("li",[t._v("当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，\n就重新开始延时")])]),t._v(" "),e("h2",{attrs:{id:"js异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js异步"}},[t._v("#")]),t._v(" js异步")]),t._v(" "),e("h2",{attrs:{id:"排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"https://www.cnblogs.com/ybygb-geng/p/9355425.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("排序"),e("OutboundLink")],1)]),t._v(" "),e("ul",[e("li",[e("p",[t._v("冒泡排序")])]),t._v(" "),e("li",[e("p",[t._v("快速排序")])]),t._v(" "),e("li",[e("p",[t._v("从小到大：arr.sort((a,b)=>a-b)")])]),t._v(" "),e("li",[e("p",[t._v("从大到小：arr.sort((a,b)=>b-a)")])])]),t._v(" "),e("h2",{attrs:{id:"reduce方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reduce方法"}},[t._v("#")]),t._v(" reduce方法")]),t._v(" "),e("ul",[e("li",[t._v("对数组的每个元素执行一个你提供的reduce函数升序，将其结果汇总为单个返回")])]),t._v(" "),e("h2",{attrs:{id:"session-token-cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#session-token-cookie"}},[t._v("#")]),t._v(" session,token,cookie")]),t._v(" "),e("ul",[e("li",[t._v("cookie是解决浏览器识别问题，服务器会在HTTP头部设置set-cookie字段，浏览器今后每开\n一次都会在HTTP请求头带着cookie上去。cookie曾充当过本地存储，但不安全，容易修改，存储量小")]),t._v(" "),e("li",[t._v("session利用了cookie，不发明文改用密文，常用于服务器做信息缓存。更安全")]),t._v(" "),e("li",[t._v("localStorage,sessionstorage是HTML5新增的本地存储")]),t._v(" "),e("li",[t._v("token利用用户特征（ip地址）进行的MD5效验码")])]),t._v(" "),e("h2",{attrs:{id:"捕获和冒泡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#捕获和冒泡"}},[t._v("#")]),t._v(" 捕获和冒泡")]),t._v(" "),e("ul",[e("li",[t._v("W3C规定，事件先从外层到里层，再从内层到外层，使用addEventListener('click',function(){},true),\n第三个参数true表示捕获，false表示冒泡")])]),t._v(" "),e("h2",{attrs:{id:"http请求的七个步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http请求的七个步骤"}},[t._v("#")]),t._v(" http请求的七个步骤")]),t._v(" "),e("ul",[e("li",[t._v("建立TCP连接{}")]),t._v(" "),e("li",[t._v("web浏览器向web服务器发送请求命令")]),t._v(" "),e("li",[t._v("web浏览器发送请求头信息")]),t._v(" "),e("li",[t._v("web服务器发送应答")]),t._v(" "),e("li",[t._v("web服务器发送应答头信息")]),t._v(" "),e("li",[t._v("web服务器向浏览器发送数据")]),t._v(" "),e("li",[t._v("web服务器关闭TCP连接")])]),t._v(" "),e("h2",{attrs:{id:"箭头函数与普通函数的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数与普通函数的区别"}},[t._v("#")]),t._v(" 箭头函数与普通函数的区别")]),t._v(" "),e("ul",[e("li",[t._v("箭头函数的this是定义时决定的，普通函数看调用方法")]),t._v(" "),e("li",[t._v("箭头函数不能成为构造函数")]),t._v(" "),e("li",[t._v("箭头函数不能使用async/await")]),t._v(" "),e("li",[t._v("箭头函数不能加星")])])])}),[],!1,null,null,null);a.default=_.exports}}]);