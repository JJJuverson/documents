(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{404:function(t,s,a){"use strict";a.r(s);var e=a(3),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"浏览器与计算机基础部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器与计算机基础部分"}},[t._v("#")]),t._v(" 浏览器与计算机基础部分")]),t._v(" "),a("h3",{attrs:{id:"网络的七层模型："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络的七层模型："}},[t._v("#")]),t._v(" 网络的七层模型：")]),t._v(" "),a("p",[t._v("应用层：DNS,FTP,HTTP,talnet，电子邮件smtp等\n表示层 数据的表示和加密\n会话层 建立管理终止会话\n传输层 tcp udp\n网络层 IP icmp\n数据链路层\n物理层")]),t._v(" "),a("h3",{attrs:{id:"tcp与udp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp"}},[t._v("#")]),t._v(" Tcp与udp")]),t._v(" "),a("p",[t._v("Tcp:面向连接，udp无连接即发送数据前不需要建立连接\nTcp提供可靠服务，通过tcp发送的数据无差错，不丢失，不重复，udp尽最大努力交付，不保证可靠交付\nTcp面向字节流。upd面向报文，在网络堵塞时也不会影响发送速率，因此可能就出现丢包现象\nTcp只1对1，而udp可以一对一，一对多")]),t._v(" "),a("h3",{attrs:{id:"http-与-https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-与-https"}},[t._v("#")]),t._v(" Http 与 https")]),t._v(" "),a("p",[t._v("http:超文本传输协议\nhttps:以安全为目标的http通道，在http下加入ssl层\n区别：使用不同的链接方式，端口不同。http80端口，https443端口。连接不同，http的连接是无状态的，\n而https是由ssl+http构建的可进行加密传输、身份认证的网络协议\nhttp2.0 基于1.0，提升了访问速度，允许多路复用。")]),t._v(" "),a("h3",{attrs:{id:"websocket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" Websocket")]),t._v(" "),a("p",[t._v("是html5中的协议，支持持久连接，提供了一种在单个TCP连接上进行全双工通信的协议。允许服务器主动向客户端推送数据。\n在websocket api中浏览器和服务器只需要完成一次握手，两者就能进行持久连接，并进行数据双向传输。")]),t._v(" "),a("h3",{attrs:{id:"tcp三次握手：客户端发起请求连接服务器确认，服务器也发起连接客户端确认"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手：客户端发起请求连接服务器确认，服务器也发起连接客户端确认"}},[t._v("#")]),t._v(" Tcp三次握手：客户端发起请求连接服务器确认，服务器也发起连接客户端确认")]),t._v(" "),a("p",[t._v("第一次握手：服务器确认自己接收客服端发送的报文\n第二次：客户端确认服务器收到自己发送的报文，并且客户端可以接收服务器发送的报文\n第三次：服务器确认客户端收到了自己发送的报文")]),t._v(" "),a("h3",{attrs:{id:"状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[t._v("#")]),t._v(" 状态码")]),t._v(" "),a("p",[t._v("100 继续\n101 切换协议\n200 请求成功\n201 已创建\n202 已接受请求，但未处理完成\n204 无内容，服务器成功处理但未返回内容\n300 多种选择，请求的资源可包括多个位置\n301 永久移动，请求的资源已被永久到新的url\n302 临时移动 与301类似，但只是临时移动，客户端应继续使用原有的url\n303 查看其他地址 与301类似\n304 未修改，所请求的资源未修改\n400：请求无效，前端提交的字段名称和字段类型与后台的实体没有保持一致\n401：当前的请求需要用户验证\n403：服务器已经得到请求但是拒绝执行。\n500 服务器内部错误，无法完成请求\n501 服务器不支持请求功能\n502 从远程服务器接收到一个无效的响应\n503 由于超载或者系统维护，无法处理请求\n504 充当网关或者代理服务器未及时从远端服务器获取请求\n505 服务器不支持http协议的版本")]),t._v(" "),a("h3",{attrs:{id:"cookie-sessionstorage-localstorage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie-sessionstorage-localstorage"}},[t._v("#")]),t._v(" Cookie,sessionstorage,localstorage")]),t._v(" "),a("p",[t._v("共同点：都是保存在浏览器端，并且是同源的\nCookie数据有路径的概念，cookie只存在于某个路径下，同时数据不能超过4K，同时每次http请求都会携带cooki·e\nSessionstorage：仅在当前浏览器窗口未被关闭时有效。Localstorage始终有效，保存在本地中，因此用作数据持久化\n他们作用域不同：sessionstorage不在不同浏览器窗口中共享。Localstorage与cookie在所有同源窗口中共享")]),t._v(" "),a("h3",{attrs:{id:"cookie与session和token"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie与session和token"}},[t._v("#")]),t._v(" Cookie与session和token")]),t._v(" "),a("p",[t._v("Cookie数据存放在客户端浏览器上，而session数据存放在服务器中\nCookie不安全，别人可以分析存放本地的cookie进行cookie欺骗\ntoken利用用户特征（ip地址）进行的MD5效验码\nSession会在一定时间内保存在服务器上，会占用服务器性能")]),t._v(" "),a("h3",{attrs:{id:"浏览器缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),a("p",[t._v("缓存分为：强缓存和协商缓存，根据响应的header内容来决定\n强缓存（200）不发送请求到服务器直接从缓存中取\n协商缓存（304）发送请求给服务器来告诉缓存是否可用\n强缓存相关字段：expires,cache-control,cache-control优先级高于expires\n协商缓存：last-modified/if-modified-since,etag/if-none-match")]),t._v(" "),a("h2",{attrs:{id:"前端及html-css"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端及html-css"}},[t._v("#")]),t._v(" 前端及html,css")]),t._v(" "),a("h3",{attrs:{id:"html5新增元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html5新增元素"}},[t._v("#")]),t._v(" Html5新增元素")]),t._v(" "),a("p",[t._v("增加了header,footer,nav,aside,section语义化标签\n")]),a("header",[t._v("顶部标签")]),t._v(" "),a("nav",[t._v("导航栏标签")]),t._v(" "),a("section",[t._v("中心标签")]),t._v(" "),a("article",[t._v("文章标签")]),t._v(" "),a("footer",[t._v("底部标签")]),a("p"),t._v(" "),a("p",[t._v("表单方面：为input增加了color,emial,data,range等类型\n存储方面：提供了sessionstorage,localstorage和离线存储\n多媒体：规定了音频和视频元素audio与vedio\n另外还有地理定位，canvas画布，拖放，多线程编程web worker和websocket协议")]),t._v(" "),a("p",[t._v("语义化标签优点：\n代码结构清晰，方便阅读，有利于团队合作开发。\n方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。\n有利于搜索引擎优化（SEO）。")]),t._v(" "),a("h3",{attrs:{id:"css属性position都有哪些值？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css属性position都有哪些值？"}},[t._v("#")]),t._v(" css属性position都有哪些值？")]),t._v(" "),a("p",[t._v("absolute绝对定位\nrelative相对定位\nfixed固定定位\nsticky粘性定位\nstatic默认值，没有定位\ninherit继承父系\ninitial设置该属性为默认值")]),t._v(" "),a("h3",{attrs:{id:"cors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cors"}},[t._v("#")]),t._v(" CORS")]),t._v(" "),a("p",[t._v("跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)\n上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、\n协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。\n而CORS 允许浏览器向跨源服务器，发出跨域请求，从而克服了AJAX只能同源使用的限制。\nCORS是一个W3C标准，它同时需要浏览器和服务端的支持，浏览器基本都支持，因此，想要实现CORS通信，\n只要服务器实现了CORS接口即可")]),t._v(" "),a("h3",{attrs:{id:"在javascript中什么情况下会进行装箱-拆箱转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在javascript中什么情况下会进行装箱-拆箱转换"}},[t._v("#")]),t._v(" 在Javascript中什么情况下会进行装箱/拆箱转换?")]),t._v(" "),a("p",[t._v("装箱：把基本数据类型转换成对应的引用类型的操作。\n拆箱：把引用类型转换成基本数据类型的操作。\n在Javascript中出现 基本数据类型数据 和 引用数据类型数据要进行转换的情况下会进行装箱/拆箱操作。")]),t._v(" "),a("h3",{attrs:{id:"简述cookie-session记住登录状态机制原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述cookie-session记住登录状态机制原理"}},[t._v("#")]),t._v(" 简述cookie/session记住登录状态机制原理")]),t._v(" "),a("p",[t._v("用户登录验证成功后，如果是使用 Cookie 记住登录状态，则服务器会将用户名等信息\n放在响应头的 Set-Cookie 属性中返回给服务器，之后的 HTTP 请求都会携带这个 Cookie ，\n实现记住登录。如果是 session 的话，则服务器会将用户名等信息存放在本地，\n再随机生成一个登录标识通过 Cookie 返回给浏览器，之后浏览器每次发送请求也会携带这个 Cookie，\n服务器收到后便通过这个标识得到已登录的用户信息。")]),t._v(" "),a("h3",{attrs:{id:"dom-tree与render-tree之间的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-tree与render-tree之间的区别是什么"}},[t._v("#")]),t._v(" DOM Tree与Render Tree之间的区别是什么?")]),t._v(" "),a("p",[t._v("Dom Tree 包含了所有的HTMl标签，包括display：none  ，JS动态添加的元素等。\nDom Tree 和样式结构体结合后构建呈现Render Tree。Render Tree 能识别样式，每个node都有自己的style，\n且不包含隐藏的节点（比如display : none的节点）。")]),t._v(" "),a("h3",{attrs:{id:"除了px外的css度量单位并解释其含义。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#除了px外的css度量单位并解释其含义。"}},[t._v("#")]),t._v(" 除了px外的CSS度量单位并解释其含义。")]),t._v(" "),a("p",[t._v("px:相对长度单位。相对于屏幕分辨率而言。\n特点：IE无法调整使用px作为单位的字体大小\nem：相对长度单位，相对于当前对象文本的字体尺寸，如果尺寸未设置，则相对于浏览器默认字体尺寸。\nem的值不固定，会继承父元素的字体大小\nrem：相对于根元素（HTML元素）大小的单位，可以根据设计稿用js动态设置大小。\nvw,vh：视口单位，针对当前页面的可视范围进行100等分的划分。")]),t._v(" "),a("p",[t._v("对于只需要适配少部分手机设备，且分辨率对页面影响不大，使用px\n对于需要适配各种移动设备，使用rem。")]),t._v(" "),a("h3",{attrs:{id:"css盒子模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css盒子模型"}},[t._v("#")]),t._v(" Css盒子模型")]),t._v(" "),a("p",[t._v("标准盒模型：content、padding、border、margin并且content不包含其他部分\nIE盒子模型：content、padding、border、margin并且content包含padding和border\ncss3的box-sizing属性给了开发者选择盒模型解析方式的权利。W3C的盒模型方式被称为“content-box”，\nIE的被称为“border-box”，使用box-sizing: border-box;就是为了在设置有padding值和border值的时候不把宽度撑开")]),t._v(" "),a("h3",{attrs:{id:"flex布局与grid网格布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex布局与grid网格布局"}},[t._v("#")]),t._v(" flex布局与Grid网格布局")]),t._v(" "),a("p",[t._v("flex布局又叫弹性布局，基于盒模型，依赖display属性+position属性+float属性。它对于都些特殊布局非常方便，比如垂直居中\nflex-direction 决定主轴方向，flex-wrap决定换行规则，justify-content,水平对齐方式，align-items 垂直对齐方式\nflex布局是轴线布局，指定针对轴线的位置，Grid布局则是将容器换份为行和列，产生单元格")]),t._v(" "),a("h3",{attrs:{id:"bfc（块级格式化上下文）用于清除浮动，防止margin重叠"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfc（块级格式化上下文）用于清除浮动，防止margin重叠"}},[t._v("#")]),t._v(" BFC（块级格式化上下文）用于清除浮动，防止margin重叠")]),t._v(" "),a("p",[t._v("Bfc是一个独立的渲染区域，其中的元素布局不受外界影响，并且有一定的布局规则。\n块盒和行盒（行盒由一行中所有的内联元素构成）都会垂直的沿着父元素的边框排列\n如何创建BFC：\nFloat的值不会none\nposition的值不为static或者relative,\ndisplay的值为inline-block,table-cell,table-caption、inline-flex\noverflow不为visible\nBfc作用：利用BFC避免margin重叠，自适应两栏布局，清楚浮动")]),t._v(" "),a("h3",{attrs:{id:"重绘和重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重绘和重排"}},[t._v("#")]),t._v(" 重绘和重排")]),t._v(" "),a("p",[t._v("Dom的变化影响到了内部的几何属性，比如宽高等，浏览器重新计算元素的几何属性，其他元素的也会收到影响，\n浏览器重新构造渲染树，这个过程称之为重排。浏览器将收到影响的部分重新绘制在屏幕上的过程称之为重绘\n减少：对于多次重排的元素比如动画，使用绝对定位脱离文档流，使其不受其他元素影响。\n使用classText，className一次性改变属性")]),t._v(" "),a("h3",{attrs:{id:"前端优化："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端优化："}},[t._v("#")]),t._v(" 前端优化：")]),t._v(" "),a("p",[t._v("降低请求量：合并资源减少http请求数\n加快请求速度：预解析dns，减少域名数，并行加载，cdn分发\n缓存 http协议缓存请求，离线缓存，离线数据缓存\n渲染： js/css优化，加载顺序，服务端渲染")]),t._v(" "),a("h2",{attrs:{id:"js相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js相关"}},[t._v("#")]),t._v(" js相关")]),t._v(" "),a("h3",{attrs:{id:"get-post"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-post"}},[t._v("#")]),t._v(" Get/post")]),t._v(" "),a("p",[t._v("Get-从服务器上获取数据，Post-向服务器传送数据\nGet把参数包含在URL中，post通过提交表单的方式传递数据\nGET长度有限制，post一般可以很大且post比get安全\nGet用户获取数据时可以使用缓存，而post一般用户修改和删除工作，不能使用缓存。\nGet只能进行url编码，post可以进行多种编码\nGet,post本质上就是tcp连接，并无差别\nGet产生一个tcp数据包，post产生两个")]),t._v(" "),a("h3",{attrs:{id:"事件循环："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环："}},[t._v("#")]),t._v(" 事件循环：")]),t._v(" "),a("p",[t._v("JavaScript 是一门单线程语言，异步操作都是放到事件循环队列里面，等待主执行栈来执行的，并没有专门的异步执行线程。\n同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入 Event Queue 。\n主线程内的任务执行完毕为空，会去 Event Queue 读取对应的任务，推入主线程执行。\n上述过程的不断重复就是我们说的 Event Loop (事件循环)。")]),t._v(" "),a("h3",{attrs:{id:"js-闭包，垃圾回收机制，内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-闭包，垃圾回收机制，内存泄漏"}},[t._v("#")]),t._v(" Js:闭包，垃圾回收机制，内存泄漏")]),t._v(" "),a("p",[t._v("闭包：函数嵌套函数\n特点：在一个函数内部定义另一个函数，并且返回内部函数或者立即执行内部函数\n内部函数可以读取外部函数的局部变量\n让内部函数一直存在于内存中避免垃圾回收机制回收。")]),t._v(" "),a("p",[t._v("垃圾回收：Js中的内存管理是自动进行的额，而且不可见，当我们创建基本类型，对象函数等这些都需要内存，\n当不再需要这些东西时，js引擎中的一个后台进程称之为垃圾回收机制，它监视所有对象，并删除这些不再需要的对象")]),t._v(" "),a("p",[t._v("内存泄漏：就是没有及时释放不在需要的内存，当内存泄漏越来越高时，会带来性能问题，严重时造成崩溃。\n引起内存泄漏的原因可能是闭包，定时器settimeval或者settimeout在不需要使用时未被clear。\n控制台日志没有被清除。使用严格模式，定时清理不再需要的元素。")]),t._v(" "),a("h3",{attrs:{id:"原型，原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型，原型链"}},[t._v("#")]),t._v(" 原型，原型链")]),t._v(" "),a("p",[t._v("原型：构造函数的prototype将成为new出来实例的原型，原型的功能就是将所有类的函数方法写在原型prototype上，节约内存\n原型链：当试图访问一个对象属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象原型的原型，\n一次向下搜索，直到找到一个名字匹配的属性或者达到原型链的末端")]),t._v(" "),a("h3",{attrs:{id:"类的创建：new一个function，在这个function的prototype里增加属性和方法。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的创建：new一个function，在这个function的prototype里增加属性和方法。"}},[t._v("#")]),t._v(" 类的创建：new一个function，在这个function的prototype里增加属性和方法。")]),t._v(" "),a("h3",{attrs:{id:"类的继承：原型链继承，构造继承，实例继承和拷贝继承，组合继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的继承：原型链继承，构造继承，实例继承和拷贝继承，组合继承"}},[t._v("#")]),t._v(" 类的继承：原型链继承，构造继承，实例继承和拷贝继承，组合继承")]),t._v(" "),a("ul",[a("li",[t._v("原型链继承，将父类的实例作为子类的原型（实例是子类的实例，也是父类的实例，父类新增的原型方法，子类也能访问到）")]),t._v(" "),a("li",[t._v("构造继承，使用父类的构造函数来增强子类实例，等于复制父类的实例给子类")]),t._v(" "),a("li",[t._v("实例继承，为父类的实例增加新的特性，作为子类实例返回")]),t._v(" "),a("li",[t._v("拷贝继承，")]),t._v(" "),a("li",[t._v("组合继承，通过父类构造，继承父类的属性并保留传参的特点，然后通过父类实例作为子类原型，实现函数复用\n-")])]),t._v(" "),a("h3",{attrs:{id:"call-bind-apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-bind-apply"}},[t._v("#")]),t._v(" Call bind apply")]),t._v(" "),a("ul",[a("li",[t._v("定义上下文，指定上下文执行函数。改变函数内部this指针的指向函数")]),t._v(" "),a("li",[t._v("Bind终身指定上下文，但不执行函数，返回新的函数")]),t._v(" "),a("li",[t._v("Call与apply作用相同就是写法不同。Fun.call(对象，参数，参数…)。Fun.apply(对象，[参数，参数…])")])]),t._v(" "),a("h3",{attrs:{id:"节流，防抖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节流，防抖"}},[t._v("#")]),t._v(" 节流，防抖")]),t._v(" "),a("ul",[a("li",[t._v("节流：针对调用频率高的函数，通过定时器，使其在执行后间隔一段时间，才进行下次执行，\n避免重复调用导致浏览器性能以及ajax重复调用的问题。")])]),t._v(" "),a("div",{staticClass:"language-滚动监听,窗口resize line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('function throttle(fn,delay){\n  let flag = true // 是否已有定时器\n  let timer = null \n  return function(...args){\n    if(!flag) return\n    flag = false\n    let _this = this\n    clearTimeout(timer) // 清除\n    timer = setTimeout(()=>{\n      fn.apply(_this,args)\n      flag = true\n    },delay)\n  }\n}\n// 使用\nlet throttleFunc = throttle(scrollEvent, 300)\ndocument.addEventListener("scroll", function () {\n  throttleFunc(123)\n})\nfunction scrollEvent(args) {\n\tconsole.log("滚动做点啥事" + args + "," + this.a);\n}\n// 滚动做点啥事123,cao\n\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br"),a("span",{staticClass:"line-number"},[t._v("24")]),a("br")])]),a("ul",[a("li",[t._v("防抖：针对于持续触发事件时，一定事件内没有再触发事件，事件处理函数才会执行一次，\n如果在设定时间到来之前又一次触发，则重新开始延时。")])]),t._v(" "),a("div",{staticClass:"language-频繁触发，第一次与不触发的时候执行函数 line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('function debounce(fn,delay){\n  let timer = null\n  return function(...arg){\n    if(timer) clearTimeout(timer)\n    let _this = this\n    timer = setTimeout(()=>{\n      fn.apply(_this,args)\n    },delay)\n  }\n}\n// 使用\nlet debounceFunc = debounce(scrollEvent, 300)\ndocument.getElementById("my_input").addEventListener("keydown", function () {\n      debounceFunc(456)\n})\nfunction scrollEvent(args) {\n  console.log("滚动做点啥事" + args + "," + this.a);\n}\n\n')])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br")])]),a("h3",{attrs:{id:"事件流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件流"}},[t._v("#")]),t._v(" 事件流")]),t._v(" "),a("p",[t._v("事件流描述从页面接收事件的顺序，主要包括事件捕获阶段，处于目标阶段，事件冒泡阶段\nAddevevtlistener是dom2新增的指定事件处理的操作，接收3个参数，处理的事件名，事件处理的函数，以及一个布尔值，true代表捕获阶段，false代表冒泡阶段")]),t._v(" "),a("h3",{attrs:{id:"事件委托：通过事件冒泡，父元素可以监听子元素事件的触发，通过判断事件发生元素dom的类型做出不同的响应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件委托：通过事件冒泡，父元素可以监听子元素事件的触发，通过判断事件发生元素dom的类型做出不同的响应"}},[t._v("#")]),t._v(" 事件委托：通过事件冒泡，父元素可以监听子元素事件的触发，通过判断事件发生元素dom的类型做出不同的响应")]),t._v(" "),a("h3",{attrs:{id:"图片预加载和懒加载实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图片预加载和懒加载实现原理"}},[t._v("#")]),t._v(" 图片预加载和懒加载实现原理")]),t._v(" "),a("ul",[a("li",[t._v("预加载：提前加载图片，用户需要查看时直接从缓存中获取")]),t._v(" "),a("li",[t._v("懒加载主要为了减少请求数或延迟请求数，缓解服务器压力\n我们先将img标签中的src链接设置为一样的图片（空白图片），将真正的图片链接放在自定义属性中，\n如（data-src），当js监听到图片元素进入到可视窗口的时候，将自定义属性中的地址存储到src中，达到懒加载的效果。")])]),t._v(" "),a("h3",{attrs:{id:"ajax请求的5个步骤："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax请求的5个步骤："}},[t._v("#")]),t._v(" ajax请求的5个步骤：")]),t._v(" "),a("p",[t._v("创建xmlhttprequest异步对象-设置回调函数与服务器建立连接向服务器发送数据\n在回调函数中针对不同的响应状态进行处理（接收返回的数据）")]),t._v(" "),a("h3",{attrs:{id:"在地址栏中输入url，到页面呈现，发生了什么："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在地址栏中输入url，到页面呈现，发生了什么："}},[t._v("#")]),t._v(" 在地址栏中输入url，到页面呈现，发生了什么：")]),t._v(" "),a("p",[t._v("主要为：DNS解析，TCP连接，发送HTTP请求，服务器处理请求并返回报文，浏览器解析渲染页面，连接结束。\n具体介绍：输入url后,首先找到这个url域名的服务器ip，为了寻找这个ip，浏览器会首先寻找缓存中是否有记录，\n首先是浏览器缓存，系统缓存，路由缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，\n得到服务器ip地址后，浏览器根据ip和端口号，构造一个http请求，这个请求报文会包括这次请求的信息和方法，\n请求说明和附带的数据，并将他们封装在一个tcp包里，这个tcp包一次经过传输层，网络层，数据链路层，和物理层到达服务器，\n解析这个请求并做出响应，返回相应的html给浏览器，浏览器根据html来构建DOM树，解析dom树，渲染dom树，将页面呈现。")]),t._v(" "),a("h3",{attrs:{id:"js实现跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js实现跨域"}},[t._v("#")]),t._v(" Js实现跨域")]),t._v(" "),a("ul",[a("li",[t._v('同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。\n所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。\njsonp利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。\nJsonp：动态创建script，再请求一个带参网址实现跨域通信。Document.domain+iframe跨域：\n两个页面都通过js强制设置document.domain为基础主域，就实现同域\nWindow.name+iframe跨域：通过iframe的src属性由外域转向本地域\nPostMessage:可以跨域操作windows属性之一\nCors:服务端设置access-control-allow-origin即可，前端无需设置，当携带cookie，前后端都需设置\n代理跨域：启一个代理服务器，实现数据的转发')]),t._v(" "),a("li",[t._v("通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改\ncookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。")])]),t._v(" "),a("h3",{attrs:{id:"requestanimationframe-raf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-raf"}},[t._v("#")]),t._v(" requestanimationFrame(raf)")]),t._v(" "),a("p",[t._v("Raf 会把每一帧中的所有dom操作集合起来，在每一次重绘和回流中完成，并且重绘和回流的时间间隔紧紧跟随浏览器的刷新效率\nRaf将不会进行重绘和回流\nRaf是浏览器专门为动画提供的api，在运行时会自动优化方法的调用，并且页面不是在激活状态下，动画会停止")]),t._v(" "),a("h3",{attrs:{id:"ajax解决浏览器缓存问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax解决浏览器缓存问题"}},[t._v("#")]),t._v(" Ajax解决浏览器缓存问题")]),t._v(" "),a("p",[t._v("在ajax发送请求前加：anyAjaxObj.setRequestHeader(“if-Modified-Since”,”0”)\n或者anyAjaxObj.setRequestHeader(“Cache-Control”,”no-cache”)\n在url后面加上随机数，或者时间搓")]),t._v(" "),a("h3",{attrs:{id:"cookie如何防范xss攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie如何防范xss攻击"}},[t._v("#")]),t._v(" Cookie如何防范xss攻击")]),t._v(" "),a("p",[t._v("Xss：攻击者在返回的html中嵌入js脚本，为了减轻这些攻击，需要在http头部配上set-cookie////\n设置属性httponly 禁止js脚本访问cookie /secure 告诉浏览器仅在请求为https时发生cookie")]),t._v(" "),a("h3",{attrs:{id:"csrf与xss网络攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csrf与xss网络攻击"}},[t._v("#")]),t._v(" Csrf与xss网络攻击")]),t._v(" "),a("p",[t._v("Csrf：跨站请求伪造，可以理解为攻击者盗用了用户的身份，防御方式：使用验证码，检查https头部的refer，使用token\nXss:跨站脚本攻击，攻击者注入恶意的脚本，防御方式：cookie设置httponly,对用户的输入进行检查")]),t._v(" "),a("h3",{attrs:{id:"js异步加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js异步加载"}},[t._v("#")]),t._v(" Js异步加载")]),t._v(" "),a("p",[t._v("Defer，支支持ie，可将defer属性加到script标签中加快处理文档的速度\nAsync，仅使用于外部脚本\n创建script标签加入到dom中")]),t._v(" "),a("h3",{attrs:{id:"处理前端模块化（分成独立的模块有利于重用和维护）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理前端模块化（分成独立的模块有利于重用和维护）"}},[t._v("#")]),t._v(" 处理前端模块化（分成独立的模块有利于重用和维护）")]),t._v(" "),a("p",[t._v("Commonjs、AMD、cmd、以及用于js打包的工具webpack")]),t._v(" "),a("h3",{attrs:{id:"commonjs、amd、cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commonjs、amd、cmd"}},[t._v("#")]),t._v(" Commonjs、amd、cmd")]),t._v(" "),a("p",[t._v("Commonjs:用于服务端的模块化，同步定义的模块化，每个模块都有一个独立的作用域，模块输出，models.export，模块加载require引入模块\nAmd:异步模块定义的意思主要用于解决以下问题\n1.对个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器中\n2.加载的时候浏览器停止渲染，页面失去响应的时间更长\nRequirejs定义了一个函数define，它是全局变量，用来定义模块\nCmd相当于按需加载，定义这个模块的时候不需要立即指定依赖模块，在需要的时候require而amd正相关，定义的时候就指定了依赖模块")]),t._v(" "),a("h3",{attrs:{id:"js各种位置clientheight-scrollheight-offsetheight-以及scrolltop-offsettop-clienttop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js各种位置clientheight-scrollheight-offsetheight-以及scrolltop-offsettop-clienttop"}},[t._v("#")]),t._v(" Js各种位置clientHeight,scrollHeight,offsetheight,以及scrolltop,offsettop,clienttop")]),t._v(" "),a("p",[t._v("Clientheight:可视区域的高度，不包含border和滚动条\nOffsetheight:可视区域的高度，包含了border和滚动条\nScrollheight:表示了所有区域的高度，包含了因为滚动被隐藏部分\nClienttop:表示边框border的厚度，在未指定时一般为0\nScrolltop:滚动后被隐藏的高度，获取对象相对于offsetparent属性指定的父坐标距离顶端的高度")]),t._v(" "),a("h3",{attrs:{id:"js类型判断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js类型判断"}},[t._v("#")]),t._v(" Js类型判断")]),t._v(" "),a("p",[t._v("Typeof , instanceof , object.prototype.toString.call\ntypeof主要用于判断数据是不是基本数据类型：String、Number、Object、Null、Undefined，但是无法判断出function、array、regExp\ninstanceof主要的目的是用来检测引用类型，判断Array和RegExp，无法准确判断Function")]),t._v(" "),a("h3",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("p",[t._v("减少http请求，使用内容发布网络cdn，添加本地缓存，压缩资源文件，将css放在顶部，js放在底部，避免使用css表达式，减少dns查询，使用外部js和css，避免重定向，图片懒加载")]),t._v(" "),a("ul",[a("li",[t._v("http请求的释放都需要时间，如果http请求太多，就会花费大量的时间在建立和释放上面")])]),t._v(" "),a("h3",{attrs:{id:"js语言特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js语言特性"}},[t._v("#")]),t._v(" Js语言特性")]),t._v(" "),a("p",[t._v("运行在客户端浏览器上，不用预编译直接解析执行代码，是弱语言类型，较为灵活，跨平台，脚本语言，解释性语言")]),t._v(" "),a("h3",{attrs:{id:"如何判断一个数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何判断一个数组"}},[t._v("#")]),t._v(" 如何判断一个数组")]),t._v(" "),a("p",[t._v("Typeof只能判断对象，要判断数组加一个条件，判断是否有数组的方法\nInstanceof object.prototype.call.toString")]),t._v(" "),a("h3",{attrs:{id:"手机端适配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手机端适配"}},[t._v("#")]),t._v(" 手机端适配")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("（1）通过媒体查询的方式即CSS3的meida queries。通过查询设备的宽度来执行不同的 css 代码，最终达到界面的配置@media screen and\n（2）以天猫首页为代表的 flex 弹性布局\n（3）以淘宝首页为代表的 rem+viewport缩放。根据rem将页面放大dpr倍, 然后viewport设置为1/dpr\n（4）rem 方式\n")])])]),a("h3",{attrs:{id:"null-undefined"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null-undefined"}},[t._v("#")]),t._v(" Null==undefined")]),t._v(" "),a("p",[t._v("在ecmascript中这样定义的")]),t._v(" "),a("h3",{attrs:{id:"this的指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#this的指向"}},[t._v("#")]),t._v(" This的指向")]),t._v(" "),a("p",[t._v("默认绑定：在全局环境中，this默认绑定window\n隐式绑定：被方法调用时，this隐式绑定到该直接对象\n显示绑定：通过call，bind，apply方法把对象绑定到this中\nNew绑定：通过new构造函数")]),t._v(" "),a("h3",{attrs:{id:"单击游戏卡顿或崩溃："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单击游戏卡顿或崩溃："}},[t._v("#")]),t._v(" 单击游戏卡顿或崩溃：")]),t._v(" "),a("p",[t._v("原因：内存溢出，资源过大，资源加载问题，canvas绘制频率\n解决：让垃圾回收器回收，选择图片更小的图片格式，在可视区选择预加载好的资源\n游戏的每一帧绘制间隔时间小于1000/60=16.7ms")]),t._v(" "),a("h3",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟Dom")]),t._v(" "),a("p",[t._v("Js对象结构表示dom树的结构，然后用这个树构建一个真正的dom树，当状态变更时，重新构造一个dom树，\n然后用新的与旧的进行比较，记录树的差异，把所记录的差异应用到真实dom树，视图就更新了。\n虚拟dom本质就是js与真实dom之间做了一个缓存")]),t._v(" "),a("h3",{attrs:{id:"webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[t._v("#")]),t._v(" Webpack")]),t._v(" "),a("p",[t._v("是现代js应用程序的静态资源打包器，当webpack处理应用程序时，它会递归的构建乐意依赖关系图，其中包含应用程序需要的每个模块，然后将所有模块打包成一个或多个包")]),t._v(" "),a("h2",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),a("h3",{attrs:{id:"vue生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[t._v("#")]),t._v(" Vue生命周期")]),t._v(" "),a("p",[t._v("在beforeCreate钩子函数调用的时候，是获取不到props或者data中的数据，因为这些数据初始化都在initState中\n然后执行created钩子函数时，可以访问到之前不能访问到的数据，但是这时候的组件还没被挂载，所以看不到\n接下来的会议执行之前安装的钩子函数，还是创建VDOM，最后执行安装的钩子，将VDOM渲染成真实DOM，并且渲染数据，组件中如果有子组件，会递归挂载子组件，只有当子组件全部挂载完毕，才会执行根组件的挂载钩子\n接下来是数据跟新时会调用钩子beforeUpdata和updated，分别对应跟新前和跟新后调用\n用keep-alive封装的组件不会被销毁，而缓存到内存中并执行停用的钩子。")]),t._v(" "),a("h3",{attrs:{id:"vue通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue通信"}},[t._v("#")]),t._v(" Vue通信")]),t._v(" "),a("p",[t._v("父组件通过props传递给子组件，子组件通过$emit发送事件传递给父组件这种通信方式时单向的，父组件通过props传递数据，子组件不能修改props，必须通过发送事件的方式来感知父组件修改数据\n兄弟之间可以通过查找父组件中的子组件来实现，也就是this。$ parent。$ children在$ children中可以通过组件名称查询需要的组件实例，然后进行通信\n跨多层组件可以使用API​​提供/注入。\n任意组件可以通过Vuex或者EventBus")]),t._v(" "),a("h3",{attrs:{id:"双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[t._v("#")]),t._v(" 双向绑定")]),t._v(" "),a("ul",[a("li",[t._v("首先对数据进行劫持监听，我们需要设置一个监听器observer，用来监听所有属性，如果属性发生改变，然后告诉订阅者watcher\n看是否需要更新，因为订阅者有多个，所以我们需要一个Dep来专门收集这些订阅者，然后在监听器observer和订阅者watcher之间进行统一\n管理，然后需要一个指令解析器compile对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者watcher，并替换模板数据或绑定相应的函数，\n此时当订阅者watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图\n主要三个步骤：\n1.实现一个监听器observer,用来劫持并监听所以属性，如果有变动就通知订阅者\n2.实现一个订阅者watcher，可以接收属性的变化并通知执行相应的函数，从而更新视图\n3.实现一个解析器compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器")])]),t._v(" "),a("h3",{attrs:{id:"set依赖搜集、派发更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#set依赖搜集、派发更新"}},[t._v("#")]),t._v(" $set依赖搜集、派发更新")]),t._v(" "),a("ul",[a("li",[t._v("响应式：当一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。\n这些getter/setter不可见但可被追踪，所以每个实例都对应一个watcher实例，它会将渲染过程中把接触过的数据\nproperty记录为依赖，当依赖的setter触发时会通知watcher，从而使它关联的每个组件重新渲染")]),t._v(" "),a("li",[t._v("一个实例在创建以后再添加新的属性到实例上，它不会触发视图更新，使用Vue.$set(object,key,value)将响应属性添加到对象上。")]),t._v(" "),a("li",[t._v("在数据劫持时，getter会通过dep.depend收集依赖。setter会通过dep.notify派发更新。dep用于存储依赖和派发更新。")])]),t._v(" "),a("h2",{attrs:{id:"作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),a("ul",[a("li",[t._v("可访问变量、对象和函数的集合")])]),t._v(" "),a("h2",{attrs:{id:"微任务和宏任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微任务和宏任务"}},[t._v("#")]),t._v(" 微任务和宏任务")]),t._v(" "),a("ul",[a("li",[t._v("宏任务是当前调用栈中执行的代码成为宏任务，主要包括主代码块，定时器等")]),t._v(" "),a("li",[t._v("微任务：当在此次事件循环中，执行完当前宏任务，在下一个宏任务开始前需要执行的任务，可以理解为回调\n-宏任务：I/O、setTimeout、setTimeInterva")]),t._v(" "),a("li",[t._v("微任务：process.nextTick,Promise.then")])])])}),[],!1,null,null,null);s.default=n.exports}}]);