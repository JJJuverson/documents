(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{430:function(t,e,v){"use strict";v.r(e);var a=v(3),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"vue双向绑定的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue双向绑定的原理"}},[t._v("#")]),t._v(" vue双向绑定的原理")]),t._v(" "),v("ul",[v("li",[t._v("vue数据双向绑定是通过数据劫持结合发布者-订阅方式来实现的：")]),t._v(" "),v("li",[t._v("1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者")]),t._v(" "),v("li",[t._v("2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。")]),t._v(" "),v("li",[t._v("3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。")])]),t._v(" "),v("h2",{attrs:{id:"v-if-v-show的区别（v-for的优先级比v-if高）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-if-v-show的区别（v-for的优先级比v-if高）"}},[t._v("#")]),t._v(" v-if v-show的区别（v-for的优先级比v-if高）")]),t._v(" "),v("ul",[v("li",[t._v("相同点： 两者都是在判断DOM节点是否要显示。")]),t._v(" "),v("li",[t._v("不同点：")]),t._v(" "),v("li",[t._v("实现方式： v-if是根据后面数据的真假值判断直接从Dom树上删除或重建元素节点。"),v("br"),t._v("\nv-show只是在修改元素的css样式，也就是display的属性值，元素始终在Dom树上。")]),t._v(" "),v("li",[t._v("编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；\nv-show只是简单的基于css切换；")]),t._v(" "),v("li",[t._v("编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译；\nv-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素始终被保留；")]),t._v(" "),v("li",[t._v("性能消耗：v-if有更高的切换消耗，不适合做频繁的切换；\nv-show有更高的初始渲染消耗，适合做频繁的额切换；")])]),t._v(" "),v("h2",{attrs:{id:"vue常用的修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue常用的修饰符"}},[t._v("#")]),t._v(" vue常用的修饰符")]),t._v(" "),v("ul",[v("li",[t._v("按键修饰符\ndelete(捕获删除或者退格键)")]),t._v(" "),v("li",[t._v("系统修饰符\n按下相应按键时触发鼠标或键盘事件的监听器 .ctrl .alt .shift .meta")]),t._v(" "),v("li",[t._v("鼠标按键修饰符\n.left .right .middle\n@click.middle  滚轮单击触发 click默认鼠标左键单击")]),t._v(" "),v("li",[t._v("其他修饰符\n.lazy 在默认情况下，v-model在每次input事件触发后将输入框的值与数据进行同步，\n加入lazy修饰符后，从而转变为change事件进行同步\n.number 自动将用户的输入值转变为数值类型\n.trim 自动过滤用户输入的首位空白字符")])]),t._v(" "),v("h2",{attrs:{id:"vue中key的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中key的作用"}},[t._v("#")]),t._v(" vue中key的作用")]),t._v(" "),v("ul",[v("li",[t._v("高效的更新虚拟DOM。例外vue在使用相同的标签名元素的过渡切换时，也会使用key属性，其\n目的是为了让vue区分他们")])]),t._v(" "),v("h2",{attrs:{id:"vue中data为什么必须是函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中data为什么必须是函数"}},[t._v("#")]),t._v(" vue中data为什么必须是函数")]),t._v(" "),v("ul",[v("li",[t._v("在new Vue()中data是可以作为一个对象进行操作的，然而在component中data只能以函数\n的形式存在，不能直接将对象赋值给它。\n当data是一个函数时，每个实例可以维护一份被S返回对象的独立拷贝，这样每个实例中的data不会相互影响，是独立的。")])]),t._v(" "),v("h2",{attrs:{id:"vue中的指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中的指令"}},[t._v("#")]),t._v(" vue中的指令")]),t._v(" "),v("ul",[v("li",[t._v("v-if 判断是否隐藏")]),t._v(" "),v("li",[t._v("v-for 把数据遍历出来")]),t._v(" "),v("li",[t._v("v-bind 绑定属性")]),t._v(" "),v("li",[t._v("v-model 实现双向绑定")])]),t._v(" "),v("h2",{attrs:{id:"vue中子组件调用父组件的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue中子组件调用父组件的方法"}},[t._v("#")]),t._v(" vue中子组件调用父组件的方法")]),t._v(" "),v("ul",[v("li",[t._v("1.直接在子组件中通过this.$parent.event来调用父组件的方法")]),t._v(" "),v("li",[t._v("2.子组件里用$emit向父组件中触发一个事件，父组件监听这个事件就可以了")]),t._v(" "),v("li",[t._v("3.父组件把方法传入子组件中，在子组件中直接调用这个方法")])]),t._v(" "),v("h2",{attrs:{id:"父组件中调用子组件的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父组件中调用子组件的方法"}},[t._v("#")]),t._v(" 父组件中调用子组件的方法")]),t._v(" "),v("ul",[v("li",[t._v("父组件利用ref属性操作子组件的方法")]),t._v(" "),v("li",[t._v("父：<chi")])]),t._v(" "),v("h2",{attrs:{id:"组件之间的传值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件之间的传值"}},[t._v("#")]),t._v(" 组件之间的传值")]),t._v(" "),v("h2",{attrs:{id:"路由"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[t._v("#")]),t._v(" 路由")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("路由守卫为：\n全局守卫：beforeEach\n后置守卫：afterEach\n全局解析守卫：beforeResolve\n路由独享守卫：beforeEnter")])]),t._v(" "),v("li",[v("p",[t._v("$route和 $router的区别是什么？\n$router为VueRouter的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。\n$route 是路由信息对象||跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，\n包含path,params,hash,query,fullPath,matched,name等路由信息参数。")])])]),t._v(" "),v("h2",{attrs:{id:"vuex"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[t._v("#")]),t._v(" vuex")]),t._v(" "),v("ul",[v("li",[t._v("vue属性：State、 Getter、Mutation 、Action、 Module。")])]),t._v(" "),v("h3",{attrs:{id:"state"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" State")]),t._v(" "),v("p",[t._v("一 、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data\n二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新\n三、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中")]),t._v(" "),v("h3",{attrs:{id:"getter"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#getter"}},[t._v("#")]),t._v(" Getter")]),t._v(" "),v("p",[t._v("一、getters 可以对State进行计算操作，它就是Store的计算属性\n二、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用\n三、 如果一个状态只在一个组件内使用，是可以不用getters")]),t._v(" "),v("h3",{attrs:{id:"mutation"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mutation"}},[t._v("#")]),t._v(" Mutation")]),t._v(" "),v("p",[t._v("一、Action 类似于 mutation，不同在于：\n二、Action 提交的是 mutation，而不是直接变更状态。\n三、Action 可以包含任意异步操作")])])}),[],!1,null,null,null);e.default=r.exports}}]);