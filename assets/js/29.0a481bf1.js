(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{389:function(e,a,t){"use strict";t.r(a);var s=t(3),i=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"回调函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[e._v("#")]),e._v(" 回调函数")]),e._v(" "),t("ul",[t("li",[e._v("是异步编程最基本的方式")]),e._v(" "),t("li",[e._v("回调函数就是定义函数的时候将另一个函数（回调函数）作为参数传入定义的函数当中，\n当异步操作执行完毕后再执行该回调函数，从而确保接下来的操作在异步操作之后执行。")]),e._v(" "),t("li",[e._v("回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分\n之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。")])]),e._v(" "),t("h2",{attrs:{id:"事件监听"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事件监听"}},[e._v("#")]),e._v(" 事件监听")]),e._v(" "),t("ul",[t("li",[e._v("脚本的执行不取决代码的顺序，而取决于某一个事件是否发生。")])]),e._v(" "),t("h2",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" promise")]),e._v(" "),t("ul",[t("li",[e._v("promise是一种链式调用的方式来组织异步代码，可以将原来以回调形式调用的代码改为\n链式调用。简单来说，Promise 就是用同步的方式写异步的代码，用来解决回调问题。")]),e._v(" "),t("li",[e._v("Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved\n（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，\n可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，\n它的英语意思就是“承诺”，表示其他手段无法改变。")]),e._v(" "),t("li",[e._v("Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。\n只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，\n你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，\n事件的特点是，如果你错过了它，再去监听，是得不到结果的。")])]),e._v(" "),t("h2",{attrs:{id:"发布与订阅"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布与订阅"}},[e._v("#")]),e._v(" 发布与订阅")]),e._v(" "),t("ul",[t("li",[e._v('我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，\n其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。\n这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。')])]),e._v(" "),t("h2",{attrs:{id:"生成器generators-yield"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#生成器generators-yield"}},[e._v("#")]),e._v(" 生成器Generators/yield")]),e._v(" "),t("ul",[t("li",[e._v("Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是\n可以控制函数的执行。")]),e._v(" "),t("li",[e._v("语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。")]),e._v(" "),t("li",[e._v("Generator 函数除了状态机，还是一个遍历器对象生成函数。")]),e._v(" "),t("li",[e._v("可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。")]),e._v(" "),t("li",[e._v("yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。")])]),e._v(" "),t("h2",{attrs:{id:"async-await"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[e._v("#")]),e._v(" async/await")]),e._v(" "),t("ul",[t("li",[e._v("使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：")]),e._v(" "),t("li",[e._v("async/await是基于Promise实现的，它不能用于普通的回调函数。")]),e._v(" "),t("li",[e._v("async/await与Promise一样，是非阻塞的。")]),e._v(" "),t("li",[e._v("async/await使得异步代码看起来像同步代码，这正是它的魔力所在。")]),e._v(" "),t("li",[e._v("一个函数如果加上 async ，那么该函数就会返回一个 Promise")])])])}),[],!1,null,null,null);a.default=i.exports}}]);