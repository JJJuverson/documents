(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{336:function(a,n,t){a.exports=t.p+"assets/img/gg.bfe33f42.png"},413:function(a,n,t){"use strict";t.r(n);var s=t(3),i=Object(s.a)({},(function(){var a=this,n=a.$createElement,s=a._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"进程三态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程三态"}},[a._v("#")]),a._v(" 进程三态")]),a._v(" "),s("p",[s("img",{attrs:{src:t(336),alt:"avatar"}})]),a._v(" "),s("h2",{attrs:{id:"时间复杂度计算"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度计算"}},[a._v("#")]),a._v(" 时间复杂度计算")]),a._v(" "),s("h2",{attrs:{id:"多媒体html标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多媒体html标签"}},[a._v("#")]),a._v(" 多媒体html标签")]),a._v(" "),s("h2",{attrs:{id:"canvas与svg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#canvas与svg"}},[a._v("#")]),a._v(" canvas与svg")]),a._v(" "),s("p",[a._v("SVG 指可伸缩矢量图形 (Scalable Vector Graphics)。\nSVG 用来定义用于网络的基于矢量的图形。\nSVG 使用 XML 格式定义图形。")]),a._v(" "),s("p",[a._v("canvas\nHTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，您可以控制其每一像素。\ncanvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。")]),a._v(" "),s("p",[a._v("功能区别\nSVG适合做静态图片展示\nSVG 是一种使用 XML 描述 2D 图形的语言。\nSVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。\n在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\nCanvas 通过 JavaScript 来绘制 2D 图形。\nCanvas 是逐像素进行渲染的。\n在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。")]),a._v(" "),s("p",[a._v("技术区别\ncanvas不依赖分辨率。\ncanvas支持事件处理器。\ncanvas最适合带有大型渲染区域的应用程序（比如谷歌地图）。\ncanvas复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）。\ncanvas不适合游戏应用。")]),a._v(" "),s("p",[a._v("svg依赖分辨率。\nsvg不支持事件处理器。\nsvg弱的文本渲染能力。\nsvg能够以 .png 或 .jpg 格式保存结果图像。\nsvg最适合图像密集型的游戏，其中的许多对象会被频繁重绘。")]),a._v(" "),s("h2",{attrs:{id:"transition与animation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#transition与animation"}},[a._v("#")]),a._v(" transition与animation")]),a._v(" "),s("ul",[s("li",[a._v("transition过度 可以让css的变得更平滑")]),a._v(" "),s("li",[a._v("属性：transition-property 指定过度得css属性")]),a._v(" "),s("li",[a._v("transition-duration 花费得时间")]),a._v(" "),s("li",[a._v("transition-timing-function 指定过度函数")]),a._v(" "),s("li",[a._v("transition-delay 过渡开始出现得延迟时间")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("img{\n    height:15px;\n    width:15px;\n    transition: 1s 1s height ease;/*合在一起*/\n}\n或者：\nimg{\n    height：15px;\n    width: 15px;\n    transition-property: height; //不是所有属性都能过渡，只有属性具有一个中间点值才具备过渡效果\n    transition-duration: 1s;\n    transition-delay: 1s;\n    transition-timing-function: ease;/*属性分开写*/  //liner匀速，ease-in 减速，ease-out加速，ease-in-out先减速再加速，\n    // cubic-bezier 三次贝塞尔曲线\n}\n\n\ntransiton: 过渡属性 过渡所需要时间 过渡动画函数 过渡延迟时间；\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br")])]),s("ul",[s("li",[s("p",[a._v("CSS3的animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果\n（1）animation-name：none为默认值，将没有任何动画效果，其可以用来覆盖任何动画\n（2）animation-duration：默认值为0，意味着动画周期为0，也就是没有任何动画效果\n（3）animation-timing-function：与transition-timing-function一样\n（4）animation-delay：在开始执行动画时需要等待的时间\n（5）animation-iteration-count：定义动画的播放次数，默认为1，如果为infinite，则无限次循环播放\n（6）animation-direction：默认为nomal，每次循环都是向前播放，（0-100），另一个值为alternate，动画播放为偶数次则向前播放，如果为基数词就反方向播放\n（7）animation-state：默认为running，播放，paused，暂停\n（8）animation-fill-mode：定义动画开始之前和结束之后发生的操作，默认值为none，动画结束时回到动画没开始时的状态；forwards，动画结束后继续应用最后关键帧的位置，即保存在结束状态；backwards，让动画回到第一帧的状态；both：轮流应用forwards和backwards规则。")])]),a._v(" "),s("li",[s("p",[a._v("@keyframes\nCSS3的animation制作动画效果主要包括两部分：1. 用关键帧声明一个动画，2.在animation调用关键帧声明的的动画。\n@keyframes就是关键帧。这个帧与Flash里的帧类似，一个动画中可以有很多个帧。")])])]),a._v(" "),s("h2",{attrs:{id:"opengl与webgl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#opengl与webgl"}},[a._v("#")]),a._v(" openGL与webGL")]),a._v(" "),s("ul",[s("li",[a._v("openGL用于渲染2d,3d矢量图形的跨语言跨平台的应用程序接口")]),a._v(" "),s("li",[a._v("webGL是一项用来在网页上绘制和渲染复杂三维图形，并允许用户与之交互的技术。")]),a._v(" "),s("li",[a._v("在实际应用中，前端的webGL是通过js语句，操作本地的openGL的部分接口来实现页面的图形渲染")])]),a._v(" "),s("h2",{attrs:{id:"os特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#os特点"}},[a._v("#")]),a._v(" os特点")]),a._v(" "),s("ul",[s("li",[a._v("井发性、共享性,虚拟性和异步性四个基本特征。")])]),a._v(" "),s("h2",{attrs:{id:"web-worker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#web-worker"}},[a._v("#")]),a._v(" web worker")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("h2",{attrs:{id:"变量名命名规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量名命名规则"}},[a._v("#")]),a._v(" 变量名命名规则")]),a._v(" "),s("p",[a._v("A不能以数字开头\nB只允许字母下划线和美元符号或者数字\nC不能用关键字做变量名")]),a._v(" "),s("h2",{attrs:{id:"字符串的几个方法特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串的几个方法特点"}},[a._v("#")]),a._v(" 字符串的几个方法特点")]),a._v(" "),s("p",[a._v("push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度\nshift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。\nconcat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本\nsplit() 方法用于把一个字符串分割成字符串数组")]),a._v(" "),s("h2",{attrs:{id:"使用on绑定的事件会覆盖，而addeventlistener则可以为一个元素绑定多个事件，且保证全都会被执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用on绑定的事件会覆盖，而addeventlistener则可以为一个元素绑定多个事件，且保证全都会被执行"}},[a._v("#")]),a._v(" 使用on绑定的事件会覆盖，而addEventListener则可以为一个元素绑定多个事件，且保证全都会被执行")]),a._v(" "),s("h2",{attrs:{id:"最小堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最小堆"}},[a._v("#")]),a._v(" 最小堆")]),a._v(" "),s("ul",[s("li",[a._v("是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的值")]),a._v(" "),s("li",[a._v("当删除堆顶，然后总是从堆尾将某个数先放置到堆顶，然后依次下调到符合完全二叉树的要求，即每个子树的两个子节点都比父节点大（最小堆）")])]),a._v(" "),s("h2",{attrs:{id:"如何清除浮动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何清除浮动"}},[a._v("#")]),a._v(" 如何清除浮动")]),a._v(" "),s("ul",[s("li",[a._v("盒子里使用浮动元素导致父级盒子不能被撑开")]),a._v(" "),s("li",[a._v("背景不能显示，边框不能撑开，margin,padding设置值不能正确显示")]),a._v(" "),s("li",[a._v("父元素添加overflow:hidden")]),a._v(" "),s("li",[a._v("增加一个空标签，在标签中使用clear:both")]),a._v(" "),s("li",[a._v("给浮动元素父级设置合适高度")]),a._v(" "),s("li",[a._v("使用伪元素：after,clearfix:after{content: '';\nheight: 0;\ndisplay: block;\nclear: both;\noverflow: hidden;\nvisibility: hidden;}\n.clearfix{zoom:1}")]),a._v(" "),s("li",[a._v('或者双伪元素before,after: .clearfix:before,.clearfix:after{content:"";display:block;clear:both;} .clearfix{zoom:1}')])]),a._v(" "),s("h2",{attrs:{id:"js对象实例化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js对象实例化"}},[a._v("#")]),a._v(" js对象实例化")]),a._v(" "),s("ul",[s("li",[a._v("工厂模式，构造函数模式，原型模式。")])]),a._v(" "),s("h2",{attrs:{id:"浏览器的兼容问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的兼容问题"}},[a._v("#")]),a._v(" 浏览器的兼容问题")]),a._v(" "),s("ul",[s("li",[a._v("不同的浏览器的标签默认外补丁margin与内补丁padding不同，解决方案css里增加通配符*{margin:0;padding:0}\n一般用的是css初始化样式")]),a._v(" "),s("li",[a._v("使用css Hack。css属性Hack CSS选择符Hack以及IE条件注释Hack")]),a._v(" "),s("li",[a._v("属性Hack，比如ie6能识别下划线和 * 号,ie7能识别 * 不能识别下划线，而firefox两个都不能识别")]),a._v(" "),s("li",[a._v("选择符级Hack，比如ie6能识别 * html .class{},ie7能识别 * +html .class{}等")]),a._v(" "),s("li",[a._v("ie条件注释，且条件注释只有在ie下才能生效")])]),a._v(" "),s("p",[a._v("比如：")]),a._v(" "),s("ul",[s("li",[a._v(".IE6双边距问题：IE6在浮动后，又有横向的margin，此时，该元素的外边距是其值的2倍\n解决办法：display:block;")]),a._v(" "),s("li",[a._v("IE6下无法设置1px的行高，原因是由其默认行高引起的\n解决办法：为期设置overflow:hidden;或者line-height:1px;")]),a._v(" "),s("li",[a._v("IE6中后面的一块被顶到下一行（.块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大）\n解决办法：在float的标签样式控制中加入 display:inline;将其转化为行内属性")])]),a._v(" "),s("h2",{attrs:{id:"vue2兼容ie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue2兼容ie"}},[a._v("#")]),a._v(" vue2兼容ie")]),a._v(" "),s("ul",[s("li",[a._v("安装babel-ployfill,修改config文件夹中的index.js文件，将build对象中的打包路径'/'改为'./'")]),a._v(" "),s("li",[a._v("在vue3中，首先在package.json中配置browserslist，然后安装babel-ployfill")])]),a._v(" "),s("h2",{attrs:{id:"深拷贝和浅拷贝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝"}},[a._v("#")]),a._v(" 深拷贝和浅拷贝")]),a._v(" "),s("ul",[s("li",[a._v("浅拷贝就是将B对象拷贝到A对象中，但不包含B的子对象。当B对象修改时，A对象也发生改变。")]),a._v(" "),s("li",[a._v('深拷贝就是将B对象拷贝到A对象中，递归复制了B对象的所有层级。当B对象修改时，A对象未变。\n实现浅拷贝：for...in只循环第一层，object.assign,赋值号"="\n实现深拷贝：采用递归去拷贝所有层级属性，通过json对象实现深拷贝，通过assign来实现，但是要把它赋值给一个空对象')])]),a._v(" "),s("h2",{attrs:{id:"vue单项数据流和双向绑定（语法糖）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue单项数据流和双向绑定（语法糖）"}},[a._v("#")]),a._v(" vue单项数据流和双向绑定（语法糖）")]),a._v(" "),s("ul",[s("li",[a._v("Vue中父组件变化时会传递给子组件，引起子组件的变化，但反过来，并不允许子组件直接改变父组件的值。")]),a._v(" "),s("li",[a._v("双向绑定：数据劫持和发布者订阅模式来实现.\nVue实例在初始化时，遍历在observer观察者中的所有属性，通过object.defineProperty来实现他们的存取（getter,setter）.\n任何对象的任意属性赋值都会触发该属性的setter。同时每个属性都会设置一个Dep消息订阅器，用来里路所有的watcher订阅者。\n当属性值发生改变时，触发setter函数，setter会调用Dep.notify通知每一个订阅该属性的watcher，watcher会调用自身的的update()\n函数对视图进行更新。这样就实现了双向绑定了。")]),a._v(" "),s("li")]),a._v(" "),s("h2",{attrs:{id:"排序算法总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#排序算法总结"}},[a._v("#")]),a._v(" 排序算法总结")]),a._v(" "),s("ul",[s("li",[a._v("冒泡排序 复杂度O(n^2) 比较相邻的元素，如果第一个大就交换")]),a._v(" "),s("li",[a._v("选择排序 复杂度O(n^2) 每一次从待排序的数据中选择最小或者最大的，存放在序列起始位置")]),a._v(" "),s("li",[a._v("插入排序 从无须表中取出一个元素，将它插入到有序表的合适位置，使无序表依然有序")]),a._v(" "),s("li",[a._v("希尔排序 属于插入排序，将整个有序序列分割成若干个子序列分别进行插入排序")]),a._v(" "),s("li",[a._v("归并排序")]),a._v(" "),s("li",[a._v("技术排序")]),a._v(" "),s("li",[a._v("快排 O(nlogn) 选取任意一个数据作为关键数据，然后将所有比他小的放到它前面，所有比他大的放在它后面，然后对这两部分在分割执行上述操作")]),a._v(" "),s("li",[a._v("堆排法")])]),a._v(" "),s("h2",{attrs:{id:"vue路由模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue路由模式"}},[a._v("#")]),a._v(" vue路由模式")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("Hash模式 #+Hash值的变化。并不会导致浏览器向服务器发送请求，也不会刷新页面，会触发hashchange这个事件，通过\n这个事件我们就知道hash值发生了哪些变化，通过监听hashchange来实现更新页面部分内容。\nhashchange有两个方法Hashchange.push(),将新路由添加到浏览器访问的历史栈顶\nHashchange.replace() 替换当前栈顶的路由")])]),a._v(" "),s("li",[s("p",[a._v("History模式\nHTML5新增的API pushState(),replaceState(),通过改变两个API可以改变url且不会发送请求。除此之外，浏览器跳转状态将触发\npopState事件。\n切换历史状态back,forward,go方法\nHistory模式不怕前进后退，就怕刷新，因为刷新回去请求服务器。\n会将url修改的和正常请求后端的url一样，当用户刷新页面之类的操作时，浏览器会给服务器发送请求\n这个模式需要服务器的支持，需要把所有路由重定向到根页面。当后端没有配置对应的路由处理时，则会返回404错误。")])])]),a._v(" "),s("h2",{attrs:{id:"vue解决跨域问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue解决跨域问题"}},[a._v("#")]),a._v(" vue解决跨域问题")]),a._v(" "),s("ul",[s("li",[a._v("同源：协议，域名，端口相同，跨域问题是浏览器的一种安全机制，浏览器不允许当前页面所在的源去请求另一个源。")]),a._v(" "),s("li",[a._v("vue解决方案：在vue-cli脚手架中设置proxyTable属性，在proxyTable修改配置即可")]),a._v(" "),s("li",[a._v("CORS 跨域资源共享：它定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求")]),a._v(" "),s("li",[a._v("Nginx")])])])}),[],!1,null,null,null);n.default=i.exports}}]);