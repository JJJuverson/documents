(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{388:function(a,s,n){"use strict";n.r(s);var t=n(3),r=Object(t.a)({},(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"java方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java方法"}},[a._v("#")]),a._v(" Java方法")]),a._v(" "),n("ul",[n("li",[a._v("方法是可以完成特定功能的并且可以被重复利用的代码片段。")]),a._v(" "),n("li",[a._v("main方法不需要程序员手动调用，是由JVM调用的。")]),a._v(" "),n("li",[a._v("但是除了main方法之外其他方法都需要程序员手动调用，方法只有调用才会去执行")])]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('public class Test{\n  public static void main(String[] args){\n    sumInt(100,200);\n  }\n  public static void sumInt(int x,int y){\n    int z = x + y;\n    System.out.println(x + "+" + y + "=" + z);\n  }\n}\n\n//以上x,y,z在以下的summit方法中属于局部变量，方法结束后，局部变量占用的内存会自动释放。\n')])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br")])]),n("h2",{attrs:{id:"方法怎样定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法怎样定义"}},[a._v("#")]),a._v(" 方法怎样定义")]),a._v(" "),n("ul",[n("li",[a._v("注意：以下[]里面的内容表示不是必须的，是可选的。\n1.语法\n[修饰符列表] 返回值类型  方法名(形式参数列表){\n方法体;\n}")])]),a._v(" "),n("p",[a._v("a.[修饰符列表]--不是必选项，是可选的。到目前为止，大家统一写成：public static\nb.关于返回值类型：可以是任何类型，只要是java中合法的数据类型就行，例如基本数据类型和引用数据类型\nc.返回值一般指的是一个方法执行结束之后的结果，结果通常是一个数据，所以被称为值，而且叫返回值。（void表示不返回任何值）\nd.返回值类型如果不是void时，方法结束时必须使用return 返回值\ne.只要有return关键字的语句执行，当前方法必然结束。")]),a._v(" "),n("p",[a._v("2.方法名要见名知意，在标识符命名中要求首字母小写，后面每个单词首字母大写(驼峰命名方式)。")]),a._v(" "),n("p",[a._v("3.形式参数：\n注意，形式参数列表中的每一个参数都是局部变量，方法结束后内存自动释放。\n形参有多个的话使用逗号隔开\n形参的数据类型起决定作用，形参对应的变量名是随意的。")]),a._v(" "),n("p",[a._v("4.方法体：\n由java语句构成，由;结尾，方法体中编写的代码是业务逻辑代码，且遵循自上而下的顺序执行。")]),a._v(" "),n("h2",{attrs:{id:"方法的调用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法的调用"}},[a._v("#")]),a._v(" 方法的调用")]),a._v(" "),n("p",[a._v("1.语法： 类名.方法名(实际参数列表)\n2.在接收return返回的值时，可以定义一个变量来接收\n3.在调用方法时---当进行跨类调用时类名不能省略，当在同一个类时类名可以省。\n4.调用程序不一定写到main中，main也是一个普通方法")]),a._v(" "),n("h2",{attrs:{id:"break与return"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#break与return"}},[a._v("#")]),a._v(" break与return")]),a._v(" "),n("ul",[n("li",[a._v("return终止当前的方法，break终止循环，不是一个级别。")])]),a._v(" "),n("h2",{attrs:{id:"jvm内存结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存结构"}},[a._v("#")]),a._v(" JVM内存结构")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("JVM中主要的三块内存空间：栈，堆，方法区，当然还有其他的。\n方法区：类加载器classloader，将硬盘上的xxx.class字节码文件装载到JVM的时候，\n会将字节码文件存放到方法区当中，也就是说方法区中储存的是代码片段。因为类需要加载，\n所以方法区中最先有数据。\n栈：在方法被调用时，该方法需要的内存空间在栈中被分配。方法在执行过程中所需要的内存，以及\n栈中会储存方法的局部变量。\n\n方法只有在被调用时，才会在栈中分配空间，并且调用时就是压栈，方法执行结束后，放方法\n所需的内存空间就会被释放，此时就是弹栈操作。\n\n\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br")])]),n("h2",{attrs:{id:"栈-stack-数据结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack-数据结构"}},[a._v("#")]),a._v(" 栈(stack)数据结构")]),a._v(" "),n("ul",[n("li",[a._v("数据结构：通常时储存数据的容器，而不同的容器可能存在不同的结构")]),a._v(" "),n("li",[a._v("常见数据结构：数组、链表、图、二叉树、栈、队列...")]),a._v(" "),n("li",[a._v("先进后出，进栈(push)、出栈(pop)")]),a._v(" "),n("li",[a._v("注意：处于栈顶部的元素具备活跃权")])]),a._v(" "),n("h2",{attrs:{id:"方法重载机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法重载机制"}},[a._v("#")]),a._v(" 方法重载机制")]),a._v(" "),n("ul",[n("li",[a._v("在java中，是怎样进行方法重载的\n在同一个类中，如果功能1和功能2他们的功能相似，那么可以考虑将他们的方法名一致。\n条件：在同一类中，方法名相同，参数列表不同。")]),a._v(" "),n("li",[a._v("在java中怎样进行方法区分：\n通过方法名区分，如果方法名相同，编译器会通过方法的参数类型进行方法区分")])]),a._v(" "),n("h2",{attrs:{id:"方法的递归"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法的递归"}},[a._v("#")]),a._v(" 方法的递归")]),a._v(" "),n("ul",[n("li",[a._v("方法自己调用自己")]),a._v(" "),n("li",[a._v("在实际开发中，递归不要轻易使用，能用循环代替的就用循环，递归使用不当，会导致JVM死掉")]),a._v(" "),n("li",[a._v("解决栈溢出错误：首先检查递归溢出条件对不对，假设递归条件没问题，需要手动调整JVM栈内存\n的大小，调整了大小如果还出错，只能继续调整。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);