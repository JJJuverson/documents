(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{374:function(b,a,n){b.exports=n.p+"assets/img/hash2.61cafbc7.png"},375:function(b,a,n){b.exports=n.p+"assets/img/hash3.b2a582ea.png"},440:function(b,a,n){"use strict";n.r(a);var r=n(3),v=Object(r.a)({},(function(){var b=this,a=b.$createElement,r=b._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":b.$parent.slotKey}},[r("h2",{attrs:{id:"了解常用hash算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#了解常用hash算法"}},[b._v("#")]),b._v(" 了解常用Hash算法")]),b._v(" "),r("ul",[r("li",[b._v("了解了hash基本定义，就不能不提到一些著名的hash算法，MD5 和 SHA-1 可以说是目前应用最广泛的Hash算法，而\n它们都是以 MD4 为基础设计的。")]),b._v(" "),r("li",[b._v("MD4\nMD4(RFC 1320)是 MIT 的 Ronald L. Rivest在1990年设计的，MD是 Message Digest的缩写。它适用在32位\n字长的处理器上用高速软件实现--它是基于 32 位操作数的位操作来实现的。")]),b._v(" "),r("li",[b._v("MD5\nMD5(RFC 1321)是 Rivest 于1991年对MD4的改进版本。它对输入仍以512位分组，其输出是4个32位字的级联，与MD4\n相同。MD5比MD4来得复杂，并且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好")]),b._v(" "),r("li",[b._v("SHA-1 及其他\nSHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性\n更好。SHA-1 设计时基于和MD4相同原理,并且模仿了该算法。")])]),b._v(" "),r("h2",{attrs:{id:"md5算法原理详解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#md5算法原理详解"}},[b._v("#")]),b._v(" "),r("a",{attrs:{href:"https://blog.csdn.net/hla199106/article/details/45129963",target:"_blank",rel:"noopener noreferrer"}},[b._v("MD5算法原理详解"),r("OutboundLink")],1)]),b._v(" "),r("ul",[r("li",[b._v("MD5是一个安全的散列算法，输入两个不同的明文不会得到相同的输出，根据输出值，不能得到原始的密文，其过程不可逆。\nMD5以512位分组来处理输入信息，且每一组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，\n将这四个32位分组级联后将生成一个128位的散列值。\n"),r("img",{attrs:{src:n(374),alt:"avatar"}})]),b._v(" "),r("li",[b._v("MD5的一般步骤如下：")]),b._v(" "),r("li",[b._v("1.数据填充，将输入的数据填充到数据长度是512位的倍数。具体填充规则如下："),r("br"),b._v("\n在MD5算法中，首先需要对输入信息进行填充，使其位长对512求余的结果等于448，并且填充必须进行。\n因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。填充的方法如下：")])]),b._v(" "),r("ol",[r("li",[b._v("在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。")]),b._v(" "),r("li",[b._v("在这个结果后面附加一个以64位二进制表示的填充前信息长度（单位为Bit），如果二进制表示的填充前信息长度超过64位，则取低64位。\n经过这两步的处理，信息的位长=N*512+448+64=(N+1）*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。")])]),b._v(" "),r("ul",[r("li",[b._v("2.使用128比特长的缓冲区储存中间结果和最终杂凑值，缓冲区为4个32比特以小端(little-endian)模式方式储存数据的寄存器(A,B,C,D)\n初始值分别为A=0x01234567,B=0x89ABCDEF,C=0xFEDCBA98,D=0x76543210"),r("br"),b._v("\n(每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端模式，反之为小端模式)")]),b._v(" "),r("li",[b._v("3.分组处理")]),b._v(" "),r("li",[b._v("分组处理框图："),r("br"),b._v(" "),r("img",{attrs:{src:n(375),alt:"avatar"}})]),b._v(" "),r("li",[b._v("每一组的算法流程图如下："),r("br"),b._v("\n（1）第一分组需要将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。"),r("br"),b._v("\n（2）从第二分组开始的变量为上一分组的运算结果，即A = a， B = b， C = c， D = d。\n一个MD5运算由类似的64次循环构成，分成4组16次，主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。\n每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。\n再将所得结果向左环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。\n算法的核心是包含四个循环的压缩函数"),r("br"),b._v("\nF( X ,Y ,Z ) = ( X & Y ) | ( (~X) & Z )"),r("br"),b._v("\nG( X ,Y ,Z ) = ( X & Z ) | ( Y & (~Z) )"),r("br"),b._v("\nH( X ,Y ,Z ) =X ^ Y ^ Z"),r("br"),b._v("\nI( X ,Y ,Z ) =Y ^ ( X | (~Z) )"),r("br"),b._v("\n（&是与（And），|是或（Or），~是非（Not），^是异或（Xor））")]),b._v(" "),r("li",[b._v("假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。\n（4294967296=2^(32)）")]),b._v(" "),r("li",[b._v("先定义"),r("br"),b._v("\nFF(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a=b+((a+F(b,c,d)+Mj+ti)<< s)"),r("br"),b._v("\nGG(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a=b+((a+G(b,c,d)+Mj+ti)<< s)"),r("br"),b._v("\nHH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a=b+((a+H(b,c,d)+Mj+ti)<< s)"),r("br"),b._v("\nII(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a=b+((a+I(b,c,d)+Mj+ti)<< s)"),r("br"),b._v("\n注意：“<<”表示循环左移位，不是左移位。"),r("br"),b._v("\n这四轮（共64步）是："),r("br"),b._v("\n第一轮"),r("br"),b._v("\nFF(a ,b ,c ,d ,M0 ,7 ,0xd76aa478 )"),r("br"),b._v("\nFF(d ,a ,b ,c ,M1 ,12 ,0xe8c7b756 )"),r("br"),b._v("\nFF(c ,d ,a ,b ,M2 ,17 ,0x242070db )"),r("br"),b._v("\nFF(b ,c ,d ,a ,M3 ,22 ,0xc1bdceee )"),r("br"),b._v("\nFF(a ,b ,c ,d ,M4 ,7 ,0xf57c0faf )"),r("br"),b._v("\nFF(d ,a ,b ,c ,M5 ,12 ,0x4787c62a )"),r("br"),b._v("\nFF(c ,d ,a ,b ,M6 ,17 ,0xa8304613 )"),r("br"),b._v("\nFF(b ,c ,d ,a ,M7 ,22 ,0xfd469501)"),r("br"),b._v("\nFF(a ,b ,c ,d ,M8 ,7 ,0x698098d8 )"),r("br"),b._v("\nFF(d ,a ,b ,c ,M9 ,12 ,0x8b44f7af )"),r("br"),b._v("\nFF(c ,d ,a ,b ,M10 ,17 ,0xffff5bb1 )"),r("br"),b._v("\nFF(b ,c ,d ,a ,M11 ,22 ,0x895cd7be )"),r("br"),b._v("\nFF(a ,b ,c ,d ,M12 ,7 ,0x6b901122 )"),r("br"),b._v("\nFF(d ,a ,b ,c ,M13 ,12 ,0xfd987193 )"),r("br"),b._v("\nFF(c ,d ,a ,b ,M14 ,17 ,0xa679438e )"),r("br"),b._v("\nFF(b ,c ,d ,a ,M15 ,22 ,0x49b40821 )"),r("br"),b._v("\n第二轮"),r("br"),b._v("\nGG(a ,b ,c ,d ,M1 ,5 ,0xf61e2562 )"),r("br"),b._v("\nGG(d ,a ,b ,c ,M6 ,9 ,0xc040b340 )"),r("br"),b._v("\nGG(c ,d ,a ,b ,M11 ,14 ,0x265e5a51 )"),r("br"),b._v("\nGG(b ,c ,d ,a ,M0 ,20 ,0xe9b6c7aa )"),r("br"),b._v("\nGG(a ,b ,c ,d ,M5 ,5 ,0xd62f105d )"),r("br"),b._v("\nGG(d ,a ,b ,c ,M10 ,9 ,0x02441453 )"),r("br"),b._v("\nGG(c ,d ,a ,b ,M15 ,14 ,0xd8a1e681 )"),r("br"),b._v("\nGG(b ,c ,d ,a ,M4 ,20 ,0xe7d3fbc8 )"),r("br"),b._v("\nGG(a ,b ,c ,d ,M9 ,5 ,0x21e1cde6 )"),r("br"),b._v("\nGG(d ,a ,b ,c ,M14 ,9 ,0xc33707d6 )"),r("br"),b._v("\nGG(c ,d ,a ,b ,M3 ,14 ,0xf4d50d87 )"),r("br"),b._v("\nGG(b ,c ,d ,a ,M8 ,20 ,0x455a14ed )"),r("br"),b._v("\nGG(a ,b ,c ,d ,M13 ,5 ,0xa9e3e905 )"),r("br"),b._v("\nGG(d ,a ,b ,c ,M2 ,9 ,0xfcefa3f8 )"),r("br"),b._v("\nGG(c ,d ,a ,b ,M7 ,14 ,0x676f02d9 )"),r("br"),b._v("\nGG(b ,c ,d ,a ,M12 ,20 ,0x8d2a4c8a )"),r("br"),b._v("\n第三轮"),r("br"),b._v("\nHH(a ,b ,c ,d ,M5 ,4 ,0xfffa3942 )"),r("br"),b._v("\nHH(d ,a ,b ,c ,M8 ,11 ,0x8771f681 )"),r("br"),b._v("\nHH(c ,d ,a ,b ,M11 ,16 ,0x6d9d6122 )"),r("br"),b._v("\nHH(b ,c ,d ,a ,M14 ,23 ,0xfde5380c )"),r("br"),b._v("\nHH(a ,b ,c ,d ,M1 ,4 ,0xa4beea44 )"),r("br"),b._v("\nHH(d ,a ,b ,c ,M4 ,11 ,0x4bdecfa9 )"),r("br"),b._v("\nHH(c ,d ,a ,b ,M7 ,16 ,0xf6bb4b60 )"),r("br"),b._v("\nHH(b ,c ,d ,a ,M10 ,23 ,0xbebfbc70 )"),r("br"),b._v("\nHH(a ,b ,c ,d ,M13 ,4 ,0x289b7ec6 )"),r("br"),b._v("\nHH(d ,a ,b ,c ,M0 ,11 ,0xeaa127fa )"),r("br"),b._v("\nHH(c ,d ,a ,b ,M3 ,16 ,0xd4ef3085 )"),r("br"),b._v("\nHH(b ,c ,d ,a ,M6 ,23 ,0x04881d05 )"),r("br"),b._v("\nHH(a ,b ,c ,d ,M9 ,4 ,0xd9d4d039 )"),r("br"),b._v("\nHH(d ,a ,b ,c ,M12 ,11 ,0xe6db99e5 )"),r("br"),b._v("\nHH(c ,d ,a ,b ,M15 ,16 ,0x1fa27cf8 )"),r("br"),b._v("\nHH(b ,c ,d ,a ,M2 ,23 ,0xc4ac5665 )"),r("br"),b._v("\n第四轮"),r("br"),b._v("\nII(a ,b ,c ,d ,M0 ,6 ,0xf4292244 )"),r("br"),b._v("\nII(d ,a ,b ,c ,M7 ,10 ,0x432aff97 )"),r("br"),b._v("\nII(c ,d ,a ,b ,M14 ,15 ,0xab9423a7 )"),r("br"),b._v("\nII(b ,c ,d ,a ,M5 ,21 ,0xfc93a039 )"),r("br"),b._v("\nII(a ,b ,c ,d ,M12 ,6 ,0x655b59c3 )"),r("br"),b._v("\nII(d ,a ,b ,c ,M3 ,10 ,0x8f0ccc92 )"),r("br"),b._v("\nII(c ,d ,a ,b ,M10 ,15 ,0xffeff47d )"),r("br"),b._v("\nII(b ,c ,d ,a ,M1 ,21 ,0x85845dd1 )"),r("br"),b._v("\nII(a ,b ,c ,d ,M8 ,6 ,0x6fa87e4f )"),r("br"),b._v("\nII(d ,a ,b ,c ,M15 ,10 ,0xfe2ce6e0 )"),r("br"),b._v("\nII(c ,d ,a ,b ,M6 ,15 ,0xa3014314 )"),r("br"),b._v("\nII(b ,c ,d ,a ,M13 ,21 ,0x4e0811a1 )"),r("br"),b._v("\nII(a ,b ,c ,d ,M4 ,6 ,0xf7537e82 )"),r("br"),b._v("\nII(d ,a ,b ,c ,M11 ,10 ,0xbd3af235 )"),r("br"),b._v("\nII(c ,d ,a ,b ,M2 ,15 ,0x2ad7d2bb )"),r("br"),b._v("\nII(b ,c ,d ,a ,M9 ,21 ,0xeb86d391 )")])]),b._v(" "),r("p",[b._v("所有这些完成之后，将a、b、c、d分别在原来基础上再加上A、B、C、D。"),r("br"),b._v("\n即a = a + A，b = b + B，c = c + C，d = d + D"),r("br"),b._v("\n然后用下一分组数据继续运行以上算法。")]),b._v(" "),r("ul",[r("li",[r("ol",{attrs:{start:"4"}},[r("li",[b._v("输出"),r("br"),b._v("\n最后的输出是L个分组都被处理完之后，最后一个分组的输出即为128比特的消息摘要。")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);