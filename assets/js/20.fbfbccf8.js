(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{287:function(h,s,a){h.exports=a.p+"assets/img/hash8.c482fd47.png"},435:function(h,s,a){"use strict";a.r(s);var i=a(3),t=Object(i.a)({},(function(){var h=this,s=h.$createElement,i=h._self._c||s;return i("ContentSlotsDistributor",{attrs:{"slot-key":h.$parent.slotKey}},[i("h2",{attrs:{id:"什么是simhash算法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#什么是simhash算法"}},[h._v("#")]),h._v(" 什么是Simhash算法")]),h._v(" "),i("ul",[i("li",[h._v("SimHash算法是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》中提到的"),i("br"),h._v("\n一种指纹生成算法，被应用在Google搜索引擎网页去重的工作之中。简单的说，SimHash算法主要的工作就是将文\n本进行降维，生成一个SimHash值，也就是论文中所提及的“指纹”，通过对不同文本的SimHash值进而比较海明距\n离，从而判断两个文本的相似度。对于文本去重这个问题，常见的解决办法有余弦算法、欧式距离、Jaccard相似\n度、最长公共子串等方法。但是这些方法并不能对海量数据高效的处理。")]),h._v(" "),i("li",[h._v("比如说，在搜索引擎中，会有很多相似的关键词，用户所需要获取的内容是相似的，但是搜索的关键词却是不同\n的，如“北京好吃的火锅“和”哪家北京的火锅好吃“，是两个可以等价的关键词，然而通过普通的hash计算，会产\n生两个相差甚远的hash串。而通过SimHash计算得到的Hash串会非常的相近，从而可以判断两个文本的相似程度。")])]),h._v(" "),i("h2",{attrs:{id:"simhash与传统hash函数的区别"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#simhash与传统hash函数的区别"}},[h._v("#")]),h._v(" simhash与传统hash函数的区别")]),h._v(" "),i("ul",[i("li",[h._v("传统的Hash算法只负责将原始内容尽量均匀随机地映射为一个签名值，原理上仅相当于伪随机数产生算法。传统的hash算法产生的\n两个签名，如果原始内容在一定概率下是相等的；如果不相等，除了说明原始内容不相等外，不再提供任何信息，因为即使原始内容只相\n差一个字节，所产生的签名也很可能差别很大。所以传统的Hash是无法在签名的维度上来衡量原内容的相似度，而SimHash本身属于一种\n局部敏感哈希算法，它产生的hash签名在一定程度上可以表征原内容的相似度。")]),h._v(" "),i("li",[h._v("我们主要解决的是文本相似度计算，要比较的是两个文章是否相识，当然我们降维生成了hash签名也是用于这个目的。看到这里估计\n大家就明白了，我们使用的simhash就算把文章中的字符串变成 01 串也还是可以用于计算相似度的，而传统的hash却不行。我们可以来做\n个测试，两个相差只有一个字符的文本串，“你妈妈喊你回家吃饭哦” 和 “你妈妈叫你回家吃饭啦”。\n　　通过simhash计算结果为："),i("br"),h._v("\n　　1000010010101101111111100000101011010001001111100001001011001011"),i("br"),h._v("\n　　1000010010101101011111100000101011010001001111100001101010001011"),i("br"),h._v("\n　　通过传统hash计算为："),i("br"),h._v("\n　　0001000001100110100111011011110"),i("br"),h._v("\n　　1010010001111111110010110011101")]),h._v(" "),i("li",[h._v("大家可以看得出来，相似的文本只有部分 01 串变化了，而普通的hash却不能做到，这个就是局部敏感哈希。")])]),h._v(" "),i("h2",{attrs:{id:"simhash的计算原理"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#simhash的计算原理"}},[h._v("#")]),h._v(" Simhash的计算原理")]),h._v(" "),i("ul",[i("li",[h._v("Simhash算法主要有五个过程：分词、Hash、加权、合并、降维")]),h._v(" "),i("li",[h._v("分词\n"),i("ul",[i("li",[h._v("给定一段语句，进行分词，得到有效的特征向量，然后为每一个特征向量设置1-5等5个级别的权重\n（如果是给定一个文本，那么特征向量可以是文本中的词，其权重可以是这个词出现的次数）。\n例如给定一段语句：“美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人”，分词后为：“ 美国（4）\n51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，\n其中括号里的数字代表这个单词在整条语句中的重要程度，数字越大代表越重要。")])])]),h._v(" "),i("li",[h._v("Hash\n"),i("ul",[i("li",[h._v("通过hash函数计算各个特征向量的hash值，hash值为二进制数01组成的n-bit签名。比如“美国”的hash值Hash(美国)为100101，\n“51区”的hash值Hash(51区)为“101011”。就这样，字符串就变成了一系列数字。")])])]),h._v(" "),i("li",[h._v("加权\n"),i("ul",[i("li",[h._v("在hash值的基础上，给所有特征向量进行加权，即W = Hash * weight，且遇到1则hash值和权值正相乘，\n遇到0则hash值和权值负相乘。例如给“美国”的hash值“100101”加权得到：W(美国) = 100101 4 = 4 -4 -4 4 -4 4，\n给“51区”的hash值“101011”加权得到：W(51区)=101011 5 = 5 -5 5 -5 5 5，其余特征向量类似此般操作。")])])]),h._v(" "),i("li",[h._v("合并\n"),i("ul",[i("li",[h._v("将上述各个特征向量的加权结果累加，变成只有一个序列串。拿前两个特征向量举例，例如“美国”的“4 -4 -4 4 -4 4”\n和“51区”的“5 -5 5 -5 5 5”进行累加，得到“4+5 -4+-5 -4+5 4+-5 -4+5 4+5”，得到“9 -9 1 -1 1”。")])])]),h._v(" "),i("li",[h._v("降维\n"),i("ul",[i("li",[h._v("对于n-bit签名的累加结果，如果大于0则置1，否则置0，从而得到该语句的simhash值，最后我们便可以根据不同语句\nsimhash的海明距离来判断它们的相似度。例如把上面计算出来的“9 -9 1 -1 1 9”降维（某位大于0记为1，小于0记为0），\n得到的01串为：“1 0 1 0 1 1”，从而形成它们的simhash签名。")])])]),h._v(" "),i("li",[h._v("整个流程图为"),i("br"),h._v(" "),i("img",{attrs:{src:a(287),alt:"avatar"}})])]),h._v(" "),i("h2",{attrs:{id:"simhash签名距离计算"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#simhash签名距离计算"}},[h._v("#")]),h._v(" simhash签名距离计算")]),h._v(" "),i("ul",[i("li",[h._v("我们把库里的文本都转换为simhash签名，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算\n两个simhash的相似度呢？难道是比较两个simhash的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming distance）\n就可以计算出两个simhash到底相似不相似。两个simhash对应二进制（01串）取值不同的数量称为这两个simhash的海明距离。\n举例如下： 10101 和 00110 从第一位开始依次有第一位、第四、第五位不同，则海明距离为3。对于二进制字符串的a和b，\n海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。")])]),h._v(" "),i("h2",{attrs:{id:"算法评估"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#算法评估"}},[h._v("#")]),h._v(" 算法评估")]),h._v(" "),i("ul",[i("li",[h._v("实验对比Minhash、Simhash的性能，结果如下：")]),h._v(" "),i("li",[h._v("运行速度：Simhash > Minhash")]),h._v(" "),i("li",[h._v("准确率：Minhash > Simhash")]),h._v(" "),i("li",[h._v("召回率：Simhash > Minhash")]),h._v(" "),i("li",[h._v("工程应用上，海量文本用Simhash，短文本用Minhash")])]),h._v(" "),i("h1",{attrs:{id:"python使用simhash实现文本相似性对比"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#python使用simhash实现文本相似性对比"}},[h._v("#")]),h._v(" "),i("a",{attrs:{href:"https://blog.csdn.net/weixin_43750200/article/details/84789361",target:"_blank",rel:"noopener noreferrer"}},[h._v("python使用simhash实现文本相似性对比"),i("OutboundLink")],1)]),h._v(" "),i("h1",{attrs:{id:"simhash的py实现"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#simhash的py实现"}},[h._v("#")]),h._v(" "),i("a",{attrs:{href:"https://blog.csdn.net/gzt940726/article/details/80460419",target:"_blank",rel:"noopener noreferrer"}},[h._v("simhash的py实现"),i("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=t.exports}}]);