(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{354:function(a,t,s){a.exports=s.p+"assets/img/hash1.77239a2e.png"},355:function(a,t,s){a.exports=s.p+"assets/img/hash4.bfd6b57d.png"},356:function(a,t,s){a.exports=s.p+"assets/img/hash5.f9843df4.png"},357:function(a,t,s){a.exports=s.p+"assets/img/hash6.9ad3ce94.png"},358:function(a,t,s){a.exports=s.p+"assets/img/hash7.e3345a90.png"},436:function(a,t,s){"use strict";s.r(t);var n=s(3),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"什么是hash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是hash"}},[a._v("#")]),a._v(" 什么是"),n("a",{attrs:{href:"https://www.cnblogs.com/austinspark-jessylu/p/9549260.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Hash"),n("OutboundLink")],1)]),a._v(" "),n("ul",[n("li",[a._v("Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），\n通过散列算法，变换成固定长度的输出，该输出就是散列值。该变换是一种压缩映射，也就是,\n散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一确\n定输入值。简单来说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。")]),a._v(" "),n("li",[a._v("简单解释：哈希（Hash）算法，即散列函数。它是一种单向密码体制，即它是一个从明文到密文的不可\n逆的映射，只有加密过程，没有解密过程。同时，哈希函数可以将任意长度的输入经过变化以后得到固定\n长度的输出。哈希函数的这种单向特征和输出数据长度固定的特征使得它可以生成消息或者数据。")])]),a._v(" "),n("h2",{attrs:{id:"hash表的相关基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hash表的相关基本概念"}},[a._v("#")]),a._v(" "),n("a",{attrs:{href:"https://www.cnblogs.com/maybe2030/p/4719267.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Hash表的相关基本概念"),n("OutboundLink")],1)]),a._v(" "),n("ul",[n("li",[a._v("哈希表（Hash table），是根据关键码值(Key value)而直接进行访问的数据结构。也\n就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。")]),a._v(" "),n("li",[a._v("冲突，两个不同的关键字，由于散列函数值相同，因而被映射到同一表位置上。该现象称为\n冲突(Collision)或碰撞。发生冲突的两个关键字称为该散列函数的同义词(Synonym)。简单来说就是请100个人去\n能坐70人的饭店吃饭。")])]),a._v(" "),n("h2",{attrs:{id:"哈希表和哈希函数的标准定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈希表和哈希函数的标准定义"}},[a._v("#")]),a._v(" 哈希表和哈希函数的标准定义")]),a._v(" "),n("ul",[n("li",[a._v("设所有可能出现的关键字集合记为U(简称全集)。实际发生(即实际存储)的关键字集合记为K（|K|比|U|小得多）。\n散列方法是使用函数h将U映射到表T[0..m-1]的下标上（m=O(|U|)）。这样以U中关键字为自变量，以h为函数的运算\n结果就是相应结点的存储地址。\n　　其中：\n　　① h：U→{0，1，2，…，m-1} ，通常称h为哈希函数(Hash Function)。哈希函数h的作用是压缩待处理的下标范围，\n使待处理的|U|个值减少到m个值，从而降低空间开销。\n　　② T为哈希表(Hash Table)。\n　　③ h(Ki)(Ki∈U)是关键字为Ki结点存储地址(亦称散列值或散列地址)。\n　　④ 将结点按其关键字的哈希地址存储到哈希表中的过程称为散列(Hashing)")])]),a._v(" "),n("h2",{attrs:{id:"哈希表的基本思想"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈希表的基本思想"}},[a._v("#")]),a._v(" 哈希表的基本思想")]),a._v(" "),n("ul",[n("li",[a._v("数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。那么我们\n能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要\n提起的哈希表，哈希表的做法其实很简单，就是把key通过一个固定的算法函数即所谓的哈希函数转换成一个整型数字,\n然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数\n组空间里。而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定\n位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。哈希表有多种不同的实现\n方法，接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：\n"),n("img",{attrs:{src:s(354),alt:"avatar"}})]),a._v(" "),n("li",[a._v("图中的主干部分是一个顺序存储结构数组，但是有的数组元素为空，有的对应一个值，有的对应的是一个链表，\n这就是“链表数组”。比如数组0的位置对应一个链表，链表有两个元素“496”和“896”，这说明元素“496”和“896”有着同样\n的Hash地址，这就是我们上边介绍的“冲突”或者“碰撞”。但是“链表数组”的存储方式很好地解决了Hash表中的冲突问题，\n发生冲突的元素会被存在一个对应Hash地址指向的链表中。实际上，“链表数组”就是一个指针数组，每一个指针指向一个\n链表的头结点，链表可能为空，也可能不为空。")]),a._v(" "),n("li",[a._v("举例说明拉链法的执行过程，设有一组关键字为(26，36，41，38，44，15，68，12，6，51)，用取余法构造散列函数，\n初始情况如下图所示：\n"),n("img",{attrs:{src:s(355),alt:"avatar"}})]),a._v(" "),n("li",[a._v("最终结果如下图所示：\n"),n("img",{attrs:{src:s(356),alt:"avatar"}})])]),a._v(" "),n("h2",{attrs:{id:"常用的构造散列函数的方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用的构造散列函数的方法"}},[a._v("#")]),a._v(" 常用的构造散列函数的方法")]),a._v(" "),n("p",[a._v("散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位：\n　　1. 直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a*key + b，\n其中a和b为常数（这种散列函数叫做自身函数）"),n("br"),a._v("\n　　2. 数字分析法：比如有一组value1=112233，value2=112633，value3=119033，针对这样的数我们分析数中\n3. 间两个数比较波动，其他数不变。那么我们取key的值就可以是key1=22,key2=26,key3=90。\n　　3. 平方取中法：取关键字平方后的中间几位作为散列地址。"),n("br"),a._v("\n　　4. 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）\n作为散列地址。举个例子，比如value=135790，要求key是2位数的散列值。那么我们将value变为13+57+90=160，\n然后去掉高位“1”,此时key=60"),n("br"),a._v("\n　　5. 随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。"),n("br"),a._v("\n　　6. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key % p,\np<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，\n若p选的不好，容易产生同义词。")]),a._v(" "),n("h2",{attrs:{id:"哈希表解决冲突的方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈希表解决冲突的方法"}},[a._v("#")]),a._v(" 哈希表解决冲突的方法")]),a._v(" "),n("ul",[n("li",[a._v("Hash表解决冲突的方法主要有以下两种：")]),a._v(" "),n("li",[a._v("1）开放地址法")]),a._v(" "),n("li",[a._v("如果两个数据元素的哈希值相同，则在哈希表中为后插入的数据元素另外选择一个表项。当程序查找哈希表时，\n如果没有在第一个对应的哈希表项中找到符合查找要求的数据元素，程序就会继续往后查找，直到找到一个符合查找要求的数据元素，\n或者遇到一个空的表项。开放地址法包括线性探测、二次探测以及双重散列等方法。其中线性探测法示意图如下：\n"),n("img",{attrs:{src:s(357),alt:"avatar"}})]),a._v(" "),n("li",[a._v("散列过程如下所示：\n"),n("img",{attrs:{src:s(358),alt:"avatar"}})]),a._v(" "),n("li",[a._v("2）链地址法")]),a._v(" "),n("li",[a._v("将哈希值相同的数据元素存放在一个链表中，在查找哈希表的过程中，当查找到这个链表时，必须采用线性查找方法。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);